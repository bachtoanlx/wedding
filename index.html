<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LensFlow - Client Proofing</title>
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#fafaf9">
    <meta name="mobile-web-app-capable" content="yes">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            colors: { 
                gray: { 
                    50: '#fafaf9', 100: '#f5f5f4', 200: '#e7e5e4', 300: '#d6d3d1', 
                    400: '#a8a29e', 500: '#78716c', 600: '#57534e', 700: '#44403c', 
                    800: '#292524', 900: '#1c1917', 950: '#0c0a09' 
                } 
            },
            fontFamily: { sans: ['Inter', 'sans-serif'] }
          }
        }
      }
    </script>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
      html, body { overflow-x: hidden; }
      body { 
          font-family: 'Inter', sans-serif; 
          background-color: #fafaf9; color: #292524; margin: 0;
          touch-action: manipulation; -webkit-tap-highlight-color: transparent;
      }
      html, body { -webkit-overflow-scrolling: touch; overscroll-behavior-y: none; }
      ::-webkit-scrollbar { width: 8px; }
      ::-webkit-scrollbar-track { background: #f5f5f4; }
      ::-webkit-scrollbar-thumb { background: #d6d3d1; border-radius: 4px; }
      input[type="password"]::-ms-reveal, input[type="password"]::-ms-clear { display: none; }
      .ios-scroll-fix { -webkit-overflow-scrolling: touch; will-change: transform; transform: translateZ(0); }
    </style>
</head>
<body>
    <div id="root"></div>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
     <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script>
        // === C·∫§U H√åNH FIREBASE ===
        const firebaseConfig = {
        apiKey: "AIzaSyD3FNEQkc-BgrgfYddYtAYHurQ63HL2MtE",
        authDomain: "lensflow-proofing-app.firebaseapp.com",
        projectId: "lensflow-proofing-app",
        storageBucket: "lensflow-proofing-app.firebasestorage.app",
        messagingSenderId: "996306881846",
        appId: "1:996306881846:web:f36c35d962ff8e0aa47797",
        databaseURL: "https://lensflow-proofing-app-default-rtdb.asia-southeast1.firebasedatabase.app"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
    </script>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;

        // === UTILITIES ===
        const getStorage = (key, def) => localStorage.getItem(key) ?? def;
        const arrayToObject = (array) => array.reduce((acc, photo) => { acc[photo.id] = photo; return acc; }, {});
        const objectToArray = (object) => object ? Object.values(object) : [];
       
        function compareDateTaken(a, b) {
            if (a.dateTaken && b.dateTaken) {
                const da = new Date(a.dateTaken);
                const db = new Date(b.dateTaken);
                if (!isNaN(da) && !isNaN(db)) return da - db; 
            }
            if (a.dateTaken && !b.dateTaken) return -1;
            if (!a.dateTaken && b.dateTaken) return 1;
            return a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' });
        }

        // === ICON COMPONENT (ƒê√£ th√™m maximize/minimize) ===
        const Icon = React.memo(({ name, size = 24, className = "", fill = "none", stroke = "currentColor" }) => {
            const icons = {
                heart: <svg width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke={stroke} strokeWidth="2" className={className}><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>,
                check: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><polyline points="20 6 9 17 4 12"></polyline></svg>,
                checkCircle: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>,
                message: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>,
                camera: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>,
                settings: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6m5.2-13.2l-4.2 4.2m0 6l4.2 4.2M23 12h-6m-6 0H1m13.2 5.2l-4.2-4.2m0-6l4.2-4.2"></path></svg>,
                upload: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>,
                cloud: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg>,
                download: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>,
                filter: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>,
                folder: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>,
                lock: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>,
                logOut: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>,
                x: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
                refresh: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>,
                loader: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={`${className} animate-spin`}><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg>,
                grid: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>,
                alert: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>,
                eye: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>,
                messageOn: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path><polyline points="9 10 12 13 16 9"></polyline></svg>,
                messageOff: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path><line x1="9" y1="10" x2="15" y2="10"></line></svg>,
                shield: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>,
                menu: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>,
                maximize: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>,
                minimize: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path></svg>,
            };
            return icons[name] || null;
        });
        
        // === PASSCODE/INITIALIZATION MODAL COMPONENT ===
const PasscodeModal = ({ isInitialized, onAccess, onInitialize, error, albumKey }) => {
    const [input, setInput] = useState('');
    const [internalError, setInternalError] = useState(error);
    useEffect(() => { setInternalError(error); }, [error]);
    const [adminPassword, setAdminPassword] = useState('');
    const [newPasscode, setNewPasscode] = useState('');

    const handleLogin = (e) => {
        e.preventDefault();
        if (isInitialized) { onAccess(input); } else { onInitialize(adminPassword, newPasscode); }
    };

    return (
        <div className="fixed inset-0 z-[100] bg-white/80 backdrop-blur-sm flex items-center justify-center p-4">
            <div className="bg-white border border-gray-200 p-8 rounded-2xl max-w-md w-full shadow-2xl">
                <div className="flex justify-center mb-6 text-pink-500"><Icon name={isInitialized ? "lock" : "shield"} size={48} /></div>
                <h2 className="text-2xl font-bold text-center mb-2 text-gray-900">{isInitialized ? 'Truy C·∫≠p Album' : 'Kh·ªüi T·∫°o Album'}</h2>
                <p className="text-sm text-gray-500 text-center mb-6">{isInitialized ? `Album: ${albumKey}` : 'Vui l√≤ng t·∫°o m·∫≠t kh·∫©u Admin v√† M√£ truy c·∫≠p.'}</p>
                <form onSubmit={handleLogin}>
                    {isInitialized && (<>
                            <input type="text" autoFocus value={input} onChange={(e) => { setInput(e.target.value); if (internalError) { setInternalError(false); } }} placeholder="Nh·∫≠p m√£ truy c·∫≠p (Passcode)" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded-lg px-4 py-3 focus:border-pink-500 outline-none mb-4 placeholder-gray-400" />
                            {internalError && <p className="text-red-500 text-xs text-center mb-4">M√£ truy c·∫≠p kh√¥ng h·ª£p l·ªá.</p>}
                            <button type="submit" className="w-full py-3 rounded-lg bg-pink-500 hover:bg-pink-400 text-white font-bold shadow-lg shadow-pink-500/30 transition-all">V√†o Xem Album</button>
                    </>)}
                    {!isInitialized && (<>
                            <input type="password" value={adminPassword} onChange={(e) => setAdminPassword(e.target.value)} placeholder="T·∫°o M·∫≠t kh·∫©u Admin" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded-lg px-4 py-3 focus:border-pink-500 outline-none mb-3" />
                            <input type="text" value={newPasscode} onChange={(e) => setNewPasscode(e.target.value)} placeholder="T·∫°o M√£ truy c·∫≠p Kh√°ch" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded-lg px-4 py-3 focus:border-pink-500 outline-none mb-4" />
                            {error && <p className="text-red-500 text-xs text-center mb-4">{error}</p>}
                            <button type="submit" disabled={!adminPassword || !newPasscode} className="w-full py-3 rounded-lg bg-green-600 hover:bg-green-500 text-white font-bold disabled:opacity-50 shadow-lg">Kh·ªüi T·∫°o & Truy C·∫≠p</button>
                    </>)}
                </form>
            </div>
        </div>
    );
};
        // === PHOTOCARD (ƒê√É N√ÇNG C·∫§P CH·∫§T L∆Ø·ª¢NG ·∫¢NH TH√îNG MINH) ===
const PhotoCard = React.memo(({ 
    photo, viewMode, onToggleSelect, onUpdateComment, onOpenView, allowComments, onDownload, downloadedIds, index 
}) => {
    const [isLoaded, setIsLoaded] = useState(false);
    const [localComment, setLocalComment] = useState(photo.comments || "");
    
    useEffect(() => { setLocalComment(photo.comments || ""); }, [photo.comments]);

    const handleCommentBlur = useCallback(() => {
        if (localComment !== photo.comments) onUpdateComment(photo.id, localComment);
    }, [localComment, photo.comments, photo.id, onUpdateComment]);

    const handleCardClick = useCallback(() => { onOpenView(photo); }, [photo, onOpenView]);
    const handleToggleClick = useCallback((e) => { e.stopPropagation(); onToggleSelect(photo.id); }, [photo.id, onToggleSelect]);
    const isDownloaded = downloadedIds && downloadedIds.has(photo.id);

    // === [LOGIC M·ªöI] T·ªêI ∆ØU CH·∫§T L∆Ø·ª¢NG ·∫¢NH ===
    const isPriority = index < 12;
    const displayUrl = useMemo(() => {
        if (!photo.url) return "";
        const targetSize = isPriority ? 'w1000' : 'w800'; 
        return photo.url.replace(/sz=[ws]\d+/, `sz=${targetSize}`).replace(/=w\d+/, `=${targetSize}`);
    }, [photo.url, isPriority]);

    return (
    <div className={`relative group md:rounded-xl overflow-hidden bg-white md:shadow-sm transition-all duration-200 ${photo.isSelected ? 'ring-2 ring-pink-500 shadow-md' : 'md:hover:shadow-lg'}`}>
        <div className="aspect-[3/4] md:aspect-[4/5] cursor-pointer overflow-hidden relative bg-gray-100" onClick={handleCardClick}>
            <div className={`w-full h-full bg-gray-100 transition-opacity duration-500 ${isLoaded ? 'opacity-0 absolute' : 'opacity-100'}`} />
            <img 
                src={displayUrl} 
                alt="" 
                loading={isPriority ? "eager" : "lazy"} 
                fetchPriority={isPriority ? "high" : "auto"}
                decoding="async" 
                onLoad={() => setIsLoaded(true)} 
                className={`w-full h-full object-cover transition-all duration-500 md:group-hover:scale-105 ${isLoaded ? 'opacity-100' : 'opacity-0'}`} 
                style={{ transform: 'translateZ(0)' }} 
            />
        </div>

        <div className="absolute md:translate-y-2 md:group-hover:translate-y-0 bottom-0 left-0 right-0 p-3 transition-transform duration-300 bg-white/95 border-t border-gray-100">
            <div className="flex justify-between items-center mb-2">
                <span className="text-xs font-medium text-gray-700 truncate flex-1 mr-2">{photo.name}</span>
                <div className="flex items-center gap-1">
                    <button 
                        onClick={(e) => { e.stopPropagation(); onDownload(photo); }}
                        className={`w-8 h-8 flex items-center justify-center rounded-full transition-all duration-300 ${isDownloaded ? 'bg-green-100 text-green-600 ring-1 ring-green-300 shadow-sm' : 'bg-gray-50 text-gray-400 hover:bg-blue-100 hover:text-blue-600'}`}
                        title={isDownloaded ? "ƒê√£ t·∫£i v·ªÅ (T·∫£i l·∫°i)" : "T·∫£i ·∫£nh n√†y"}
                    >
                        <Icon name={isDownloaded ? "check" : "download"} size={16} strokeWidth={isDownloaded ? 3 : 2} />
                    </button>
                    <button onClick={handleToggleClick} className={`w-8 h-8 flex items-center justify-center rounded-colors duration-200 ${photo.isSelected ? 'bg-pink-500 text-white shadow-md' : 'bg-gray-100 text-gray-400 hover:bg-gray-200'}`}>
                        {viewMode === 'CLIENT' ? <Icon name="heart" size={16} fill={photo.isSelected ? "currentColor" : "none"} /> : <Icon name="checkCircle" size={16} />}
                    </button>
                </div>
            </div>

            {(photo.isSelected || photo.comments) && (
                <div className="relative">
                    <div className={`flex items-center gap-2 text-gray-500 mb-1 ${viewMode === 'CLIENT' && !photo.comments && 'hidden'}`}>
                        <Icon name="message" size={12} />
                        <span className="text-[10px] uppercase font-bold tracking-wider text-gray-400">Y√™u c·∫ßu ch·ªânh s·ª≠a</span>
                    </div>
                    {viewMode === 'CLIENT' ? (
                        allowComments ? (
                            <textarea value={localComment} onChange={(e) => setLocalComment(e.target.value)} onBlur={handleCommentBlur} placeholder="V√≠ d·ª•: X√≥a r√°c, b√≥p eo..." className="w-full bg-gray-50 text-xs text-gray-800 p-2 rounded-lg border border-gray-200 focus:border-pink-500 focus:bg-white focus:outline-none resize-none h-16 transition-colors" />
                        ) : photo.comments ? <div className="w-full bg-gray-50 text-xs text-gray-600 p-2 rounded border border-gray-200 min-h-[40px] italic opacity-80">{photo.comments}</div> : null
                    ) : (
                        <div className="w-full bg-gray-50 text-xs text-gray-600 p-2 rounded border border-gray-200 min-h-[40px] italic">{photo.comments || "Kh√¥ng c√≥ ghi ch√∫."}</div>
                    )}
                </div>
            )}
        </div>
        {photo.isSelected && <div className="absolute top-2 right-2 bg-pink-500 text-white text-[10px] font-bold px-2 py-1 rounded shadow-md z-10">ƒê√É CH·ªåN</div>}
    </div>
    );
}, (prev, next) => prev.photo === next.photo && prev.viewMode === next.viewMode && prev.allowComments === next.allowComments && prev.downloadedIds === next.downloadedIds && prev.index === next.index);

        // === LIGHTBOX (ƒê√É N√ÇNG C·∫§P: FULLSCREEN BUTTON) ===
        const Lightbox = ({ photo, onClose, allPhotos, onToggleSelect, currentIndex, onNavigate, onDownload }) => {
            if (!photo) return null;
            
            const [scale, setScale] = useState(1);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [swipeOffset, setSwipeOffset] = useState(0);
            const [isSwiping, setIsSwiping] = useState(false);
            const [showUI, setShowUI] = useState(true); 
            const [isFullscreen, setIsFullscreen] = useState(!!document.fullscreenElement);

            const touchStartX = React.useRef(0);
            const lastTouchDistance = React.useRef(null);
            
            const [isLoadingHighRes, setIsLoadingHighRes] = useState(false);
            const [isHighResLoaded, setIsHighResLoaded] = useState(false);
            
            const currentPhoto = allPhotos[currentIndex] || photo;
            const prevPhoto = currentIndex > 0 ? allPhotos[currentIndex - 1] : null;
            const nextPhoto = currentIndex < allPhotos.length - 1 ? allPhotos[currentIndex + 1] : null;

            const getDistance = (touches) => Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);

            const toggleFullscreen = () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch((e) => { console.log(e); }); setIsFullscreen(true);
                } else {
                    if (document.exitFullscreen) { document.exitFullscreen(); setIsFullscreen(false); }
                }
            };
            useEffect(() => {
                const handleFsChange = () => setIsFullscreen(!!document.fullscreenElement);
                document.addEventListener('fullscreenchange', handleFsChange); return () => document.removeEventListener('fullscreenchange', handleFsChange);
            }, []);

            useEffect(() => {
                const preloadImage = (src) => { const img = new Image(); img.src = src; };
                if (nextPhoto) preloadImage(nextPhoto.lightboxUrl || nextPhoto.url);
                if (prevPhoto) preloadImage(prevPhoto.lightboxUrl || prevPhoto.url);
            }, [currentIndex, nextPhoto, prevPhoto]);

            useEffect(() => {
                setIsLoadingHighRes(false); setIsHighResLoaded(false); setScale(1); setPosition({ x: 0, y: 0 }); setSwipeOffset(0); lastTouchDistance.current = null; setShowUI(true); 
            }, [photo.id, photo.lightboxUrl, photo.url]);
            
            const goToPrev = useCallback(() => { if (prevPhoto) { onNavigate(prevPhoto); } }, [prevPhoto, onNavigate]);
            const goToNext = useCallback(() => { if (nextPhoto) { onNavigate(nextPhoto); } }, [nextPhoto, onNavigate]);
            
            const onTouchStart = (e) => {
                if (e.touches.length === 2) { lastTouchDistance.current = getDistance(e.touches); return; }
                if (e.touches.length === 1) {
                    lastTouchDistance.current = null;
                    if (scale > 1) { setIsDragging(true); setDragStart({ x: e.touches[0].clientX - position.x, y: e.touches[0].clientY - position.y }); } 
                    else { setIsSwiping(true); touchStartX.current = e.targetTouches[0].clientX; }
                }
            }
            const onTouchMove = (e) => {
                if (e.touches.length === 2 && lastTouchDistance.current) {
                    const newDistance = getDistance(e.touches);
                    const delta = newDistance / lastTouchDistance.current;
                    lastTouchDistance.current = newDistance;
                    setScale(prevScale => Math.max(1, Math.min(prevScale * delta, 4)));
                    return;
                }
                if (e.touches.length === 1) {
                    if (scale > 1 && isDragging) { setPosition({ x: e.touches[0].clientX - dragStart.x, y: e.touches[0].clientY - dragStart.y }); } 
                    else if (scale === 1 && isSwiping) { const diff = e.targetTouches[0].clientX - touchStartX.current; setSwipeOffset(diff * 0.2); }
                }
            }
            const onTouchEnd = () => {
                lastTouchDistance.current = null;
                if (scale > 1) { setIsDragging(false); } 
                else {
                    if (!isSwiping) return;
                    setIsSwiping(false);
                    const minSwipeDistance = 15; 
                    if (swipeOffset > minSwipeDistance && prevPhoto) { goToPrev(); } 
                    else if (swipeOffset < -minSwipeDistance && nextPhoto) { goToNext(); } 
                    else { setSwipeOffset(0); }
                }
            }
            const handleWheel = (e) => { e.preventDefault(); const delta = e.deltaY > 0 ? 0.9 : 1.1; setScale(prev => Math.max(1, Math.min(prev * delta, 4))); };
            const handleMouseDown = (e) => { if (scale > 1) { setIsDragging(true); setDragStart({ x: e.clientX - position.x, y: e.clientY - position.y }); } };
            const handleMouseMove = (e) => { if (isDragging && scale > 1) { setPosition({ x: e.clientX - dragStart.x, y: e.clientY - dragStart.y }); } };
            const handleMouseUp = () => setIsDragging(false);
            const resetZoom = () => { setScale(1); setPosition({ x: 0, y: 0 }); };
            const handleLoadHighRes = () => { setIsLoadingHighRes(true); };

            useEffect(() => { if (scale > 1.5 && !isHighResLoaded && !isLoadingHighRes) { handleLoadHighRes(); } }, [scale, isHighResLoaded, isLoadingHighRes]);
            const handleDoubleClick = (e) => { e.preventDefault(); e.stopPropagation(); if (scale === 1) { setScale(2); } else { resetZoom(); } };
            
            useEffect(() => {
                const handleKeyPress = (e) => { if (e.key === 'ArrowLeft') goToPrev(); if (e.key === 'ArrowRight') goToNext(); if (e.key === 'Escape') onClose(); };
                window.addEventListener('keydown', handleKeyPress); return () => window.removeEventListener('keydown', handleKeyPress);
            }, [goToPrev, goToNext, onClose]);
            
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center overflow-hidden bg-black" onClick={onClose} onTouchStart={onTouchStart} onTouchMove={onTouchMove} onTouchEnd={onTouchEnd} style={{ touchAction: 'none' }}>
                    <div className="absolute inset-0 z-0 overflow-hidden pointer-events-none">
                        <img src={currentPhoto.url} className="w-full h-full object-cover blur-3xl scale-150 opacity-60 transition-all duration-500 ease-linear" alt="" />
                        <div className="absolute inset-0 bg-white/85 backdrop-blur-sm"></div>
                    </div>
                    <div className={`absolute bottom-20 md:bottom-24 left-1/2 -translate-x-1/2 z-50 pointer-events-none transition-opacity duration-300 ${showUI ? 'opacity-100' : 'opacity-0'}`}>
                        <span className={`px-3 py-1 rounded-full text-[10px] font-bold shadow-sm border backdrop-blur-md ${isHighResLoaded ? 'bg-green-100/40 text-green-800 border-green-200/50' : 'bg-white/40 text-gray-600 border-white/50'}`}>{isHighResLoaded ? 'HD' : 'SD'}</span>
                    </div>

                    {/* BUTTONS */}
                    <button onClick={(e) => { e.stopPropagation(); onDownload(currentPhoto); }} className={`absolute top-4 right-28 md:top-6 md:right-32 text-gray-500 hover:text-blue-600 p-3 bg-white/50 hover:bg-white border border-gray-200 rounded-full transition-all z-50 shadow-sm backdrop-blur-md duration-300 ${showUI ? 'opacity-100' : 'opacity-0 pointer-events-none'} md:opacity-100 md:pointer-events-auto`} title="T·∫£i ·∫£nh g·ªëc"><Icon name="download" size={24} /></button>
                    <button onClick={(e) => { e.stopPropagation(); toggleFullscreen(); }} className={`absolute top-4 right-16 md:top-6 md:right-20 text-gray-500 hover:text-gray-900 p-3 bg-white/50 hover:bg-white border border-gray-200 rounded-full transition-all z-50 shadow-sm backdrop-blur-md duration-300 ${showUI ? 'opacity-100' : 'opacity-0 pointer-events-none'} md:opacity-100 md:pointer-events-auto`} title={isFullscreen ? "Tho√°t to√†n m√†n h√¨nh" : "To√†n m√†n h√¨nh"}><Icon name={isFullscreen ? "minimize" : "maximize"} size={24} /></button>
                    <button onClick={onClose} className={`absolute top-4 right-4 md:top-6 md:right-6 text-gray-500 hover:text-gray-900 p-3 bg-white/50 hover:bg-white border border-gray-200 rounded-full transition-all z-50 shadow-sm backdrop-blur-md duration-300 ${showUI ? 'opacity-100' : 'opacity-0 pointer-events-none'} md:opacity-100 md:pointer-events-auto`}><Icon name="x" size={24} /></button>

                    <div className={`absolute top-4 left-4 md:top-6 md:left-6 z-50 bg-white/80 border border-gray-100 backdrop-blur px-4 py-2 rounded-full shadow-sm max-w-[calc(100%-8rem)] transition-opacity duration-300 ${showUI ? 'opacity-100' : 'opacity-0'} md:opacity-100`}>
                        <div className="flex items-center gap-3"><span className="text-sm font-bold text-gray-800 truncate">{currentPhoto.name}</span><span className="text-xs text-gray-400 border-l border-gray-300 pl-3">{currentIndex + 1} / {allPhotos.length} {scale > 1 && `‚Ä¢ ${Math.round(scale * 100)}%`}</span></div>
                    </div>

                    {prevPhoto && (<button onClick={(e) => { e.stopPropagation(); goToPrev(); }} className={`hidden md:flex absolute left-6 top-1/2 -translate-y-1/2 text-gray-600 hover:text-gray-900 p-4 bg-white border border-gray-200 shadow-lg hover:shadow-xl rounded-full transition-all z-50`}><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="15 18 9 12 15 6"></polyline></svg></button>)}
                    {nextPhoto && (<button onClick={(e) => { e.stopPropagation(); goToNext(); }} className={`hidden md:flex absolute right-6 top-1/2 -translate-y-1/2 text-gray-600 hover:text-gray-900 p-4 bg-white border border-gray-200 shadow-lg hover:shadow-xl rounded-full transition-all z-50`}><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="9 18 15 12 9 6"></polyline></svg></button>)}

                    <div className="relative w-full h-full flex items-center justify-center" onClick={(e) => { e.stopPropagation(); }}>
                        {prevPhoto && scale === 1 && (<div className="hidden md:block absolute left-[5%] top-1/2 -translate-y-1/2 w-[15vw] h-[50vh] opacity-10 grayscale hover:grayscale-0 hover:opacity-40 scale-95 transition-all duration-500 cursor-pointer" onClick={(e) => { e.stopPropagation(); goToPrev(); }}><img src={prevPhoto.url} alt="" className="w-full h-full object-cover rounded-lg shadow-lg" /></div>)}

                        <div className="relative z-10 w-full md:w-[70vw] h-full md:h-[90vh] flex items-center justify-center">
                            <div className="relative w-full h-full flex items-center justify-center" onWheel={handleWheel} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onDoubleClick={handleDoubleClick} style={{ cursor: scale > 1 ? (isDragging ? 'grabbing' : 'grab') : 'default' }}>
                                <img src={photo.lightboxUrl || photo.url} alt="" className={`absolute max-h-full max-w-full object-contain shadow-2xl ${isHighResLoaded ? 'opacity-0' : 'opacity-100'}`} style={{ transform: scale > 1 ? `scale(${scale}) translate(${position.x / scale}px, ${position.y / scale}px)` : `translateX(${swipeOffset}px)`, transformOrigin: 'center', transition: (isSwiping || isDragging || lastTouchDistance.current) ? 'none' : 'transform 0.2s ease-out' }} draggable={false} />
                                {(isLoadingHighRes || isHighResLoaded) && (<img src={photo.originalUrl} alt="" onLoad={() => { setIsLoadingHighRes(false); setIsHighResLoaded(true); }} className={`absolute max-h-full max-w-full object-contain shadow-2xl ${isHighResLoaded ? 'opacity-100' : 'opacity-0'}`} style={{ transform: scale > 1 ? `scale(${scale}) translate(${position.x / scale}px, ${position.y / scale}px)` : `translateX(${swipeOffset}px)`, transformOrigin: 'center', transition: (isSwiping || isDragging || lastTouchDistance.current) ? 'none' : 'transform 0.2s ease-out' }} draggable={false} />)}
                            </div>
                        </div>

                        {nextPhoto && scale === 1 && (<div className="hidden md:block absolute right-[5%] top-1/2 -translate-y-1/2 w-[15vw] h-[50vh] opacity-10 grayscale hover:grayscale-0 hover:opacity-40 scale-95 transition-all duration-500 cursor-pointer" onClick={(e) => { e.stopPropagation(); goToNext(); }}><img src={nextPhoto.url} alt="" className="w-full h-full object-cover rounded-lg shadow-lg" /></div>)}
                    </div>
                    <button onClick={(e) => { e.stopPropagation(); onToggleSelect(currentPhoto.id); }} onTouchEnd={(e) => { e.stopPropagation(); e.preventDefault(); onToggleSelect(currentPhoto.id); }} onTouchStart={(e) => e.stopPropagation()} className={`absolute bottom-6 md:bottom-8 left-1/2 -translate-x-1/2 px-6 py-3 md:p-4 rounded-full transition-all z-50 flex items-center gap-2 shadow-xl duration-300 before:absolute before:-inset-6 before:content-[""] ${showUI ? 'translate-y-0 opacity-100' : 'translate-y-10 opacity-0 pointer-events-none'} md:translate-y-0 md:opacity-100 md:pointer-events-auto ${currentPhoto.isSelected ? 'bg-pink-500 text-white ring-4 ring-pink-100' : 'bg-white text-gray-700 border border-gray-200 hover:bg-gray-50'}`}>
                        <Icon name="heart" size={24} fill={currentPhoto.isSelected ? "currentColor" : "none"} />
                        <span className="text-sm font-bold">{currentPhoto.isSelected ? 'ƒê√É CH·ªåN' : 'CH·ªåN ·∫¢NH'}</span>
                    </button>
                </div>
            );
        };
        
        // === [M·ªöI] COMPONENT L∆Ø·ªöI ·∫¢O T·ª∞ VI·∫æT (C√≥ h·ªó tr·ª£ Scroll To Index) ===
        const SimpleFixedSizeGrid = React.memo(React.forwardRef(({ columnCount, columnWidth, height, rowCount, rowHeight, width, children: Cell, itemData, className, style, overscanRowCount = 2 }, ref) => {
            const [scrollTop, setScrollTop] = useState(0);
            const containerRef = React.useRef(null);

            React.useImperativeHandle(ref, () => ({
                scrollToItem: (index) => {
                    if (!containerRef.current) return;
                    const rowIndex = Math.floor(index / columnCount);
                    const targetScrollTop = rowIndex * rowHeight;
                    containerRef.current.scrollTo({ top: targetScrollTop, behavior: 'auto' });
                }
            }));

            const handleScroll = (e) => { setScrollTop(e.target.scrollTop); };
            const startIndex = Math.floor(scrollTop / rowHeight);
            const endIndex = Math.min(rowCount - 1, Math.floor((scrollTop + height) / rowHeight) + overscanRowCount);
            const items = [];
            const renderStart = Math.max(0, startIndex - 1); 
            
            for (let rowIndex = renderStart; rowIndex <= endIndex; rowIndex++) {
                for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {
                    const key = `${rowIndex}-${columnIndex}`;
                    const itemStyle = { position: 'absolute', top: rowIndex * rowHeight, left: columnIndex * columnWidth, height: rowHeight, width: columnWidth };
                    items.push(<Cell key={key} columnIndex={columnIndex} rowIndex={rowIndex} style={itemStyle} data={itemData} />);
                }
            }

            return (
                <div ref={containerRef} className={className} style={{ ...style, height, width, overflow: 'auto', position: 'relative', WebkitOverflowScrolling: 'touch' }} onScroll={handleScroll}>
                    <div style={{ height: rowCount * rowHeight, width: '100%', position: 'relative' }}>{items}</div>
                </div>
            );
        }));

        // === VIRTUAL GRID COMPONENT (C√≥ Ref ƒë·ªÉ App g·ªçi) ===
        const VirtualPhotoGrid = React.memo(React.forwardRef(({ photos, viewMode, onToggleSelect, onUpdateComment, onOpenView, allowComments, onDownload, downloadedIds }, ref) => {
            const containerRef = React.useRef(null);
            const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

            useEffect(() => {
                if (!containerRef.current) return;
                const resizeObserver = new ResizeObserver(entries => { for (let entry of entries) { setDimensions({ width: entry.contentRect.width, height: entry.contentRect.height }); } });
                resizeObserver.observe(containerRef.current); return () => resizeObserver.disconnect();
            }, []);

            const getColumnCount = (width) => {
                if (width < 600) return 1;
                if (width < 900) return 2;
                if (width < 1300) return 3;
                return 4;
            };

            const columnCount = dimensions.width > 0 ? getColumnCount(dimensions.width) : 4;
            const itemWidth = Math.floor((dimensions.width - 4) / columnCount); 
            const imageRatio = 5 / 4; 
            const footerHeight = 60; 
            const itemHeight = (itemWidth * imageRatio) + footerHeight; 
            const rowCount = Math.ceil(photos.length / columnCount);

            const itemData = useMemo(() => ({
                photos, columnCount, viewMode, onToggleSelect, onUpdateComment, onOpenView, allowComments, itemWidth, onDownload, downloadedIds 
            }), [photos, columnCount, viewMode, onToggleSelect, onUpdateComment, onOpenView, allowComments, itemWidth, onDownload, downloadedIds]);

            const Cell = useCallback(({ columnIndex, rowIndex, style, data }) => {
                const idx = rowIndex * data.columnCount + columnIndex;
                if (idx >= data.photos.length) return null;
                const photo = data.photos[idx];
                const gap = 12; 
                const itemStyle = { ...style, width: style.width - gap, height: style.height - gap, left: style.left + (gap / 2), top: style.top + (gap / 2) };
                return (
                    <div style={itemStyle}>
                        <PhotoCard photo={photo} viewMode={data.viewMode} onToggleSelect={data.onToggleSelect} onUpdateComment={data.onUpdateComment} onOpenView={data.onOpenView} allowComments={data.allowComments} onDownload={data.onDownload} downloadedIds={data.downloadedIds} index={idx} />
                    </div>
                );
            }, []);

            if (dimensions.width === 0) return <div ref={containerRef} className="w-full h-full" />;

            return (
                <div ref={containerRef} className="w-full h-full overflow-hidden">
                    <SimpleFixedSizeGrid ref={ref} className="ios-scroll-fix" columnCount={columnCount} columnWidth={itemWidth} height={dimensions.height} rowCount={rowCount} rowHeight={itemHeight} width={dimensions.width} itemData={itemData} overscanRowCount={2}>
                        {Cell}
                    </SimpleFixedSizeGrid>      
                </div>
            );
        }));

        const AlbumEntryPage = () => {
            const [albumName, setAlbumName] = useState('');
            const handleSubmit = (e) => { e.preventDefault(); if (!albumName.trim()) return; const name = albumName.trim(); const key = name.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase(); window.location.search = `?album=${key}&name=${encodeURIComponent(name)}`; };
            return (
                <div className="flex items-center justify-center h-screen bg-gray-50">
                    <div className="bg-white border border-gray-200 p-8 rounded-2xl max-w-md w-full shadow-xl">
                        <div className="flex justify-center mb-6 text-pink-500"><Icon name="camera" size={40} /></div>
                        <h1 className="text-2xl font-bold text-center mb-2 text-gray-900">LensFlow Proofing</h1>
                        <p className="text-sm text-gray-500 text-center mb-8">Client Proofing & Selection</p>
                        <form onSubmit={handleSubmit}>
                            <label className="text-sm font-medium text-gray-700 mb-2 block">T√™n Album</label>
                            <input type="text" value={albumName} onChange={e => setAlbumName(e.target.value)} autoFocus placeholder="Nh·∫≠p t√™n ƒë·ªÉ t·∫°o ho·∫∑c truy c·∫≠p..." className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded-lg px-4 py-3 focus:border-pink-500 outline-none mb-4 placeholder-gray-400" />
                            <button type="submit" disabled={!albumName.trim()} className="w-full py-3 rounded-lg bg-pink-500 hover:bg-pink-400 text-white font-bold disabled:opacity-50 shadow-lg shadow-pink-500/20">Ti·∫øp t·ª•c</button>
                        </form>
                    </div>
                </div>
            );
        };

        // === APP COMPONENT ===
        const App = ({ albumKey, initialAlbumName }) => {
            const gridRef = React.useRef(null); 

            const [photos, setPhotos] = useState([]);
            const [viewMode, setViewMode] = useState('CLIENT');
            const [filterMode, setFilterMode] = useState('ALL');
            const [selectedPhoto, setSelectedPhoto] = useState(null);
            const [downloadedIds, setDownloadedIds] = useState(() => { try { const saved = localStorage.getItem(`lensflow_downloaded_${albumKey}`); return saved ? new Set(JSON.parse(saved)) : new Set(); } catch { return new Set(); } });
            const markAsDownloaded = useCallback((photoId) => { setDownloadedIds(prev => { const newSet = new Set(prev); newSet.add(photoId); localStorage.setItem(`lensflow_downloaded_${albumKey}`, JSON.stringify([...newSet])); return newSet; }); }, [albumKey]);
            
            const [albumName, setAlbumName] = useState(initialAlbumName || "Ch∆∞a ƒë·∫∑t t√™n");
            const [allowComments, setAllowComments] = useState(true);
            const [adminPassword, setAdminPassword] = useState(""); 
            const [driveApiKey, setDriveApiKey] = useState("");
            const [driveFolders, setDriveFolders] = useState([]);
            const [currentFolderId, setCurrentFolderId] = useState('');
            const [lastSaveTime, setLastSaveTime] = useState(null); 
            const [isAuthenticated, setIsAuthenticated] = useState(false);
            const [showLoginModal, setShowLoginModal] = useState(false);
            const [passwordInput, setPasswordInput] = useState("");
            const [loginError, setLoginError] = useState(false);
            const [notification, setNotification] = useState(null);
            const [isSyncingDrive, setIsSyncingDrive] = useState(false);
            const [syncProgress, setSyncProgress] = useState({ current: 0, total: 0, folderName: '' });
            const [isMovingFiles, setIsMovingFiles] = useState(false);
            const [moveProgress, setMoveProgress] = useState({ current: 0, total: 0, fileName: '' });
			const [showDownloadMenu, setShowDownloadMenu] = useState(false);
			const cancelDownloadRef = React.useRef(false);

            const handleSmartDownload = async (type) => {
                setShowDownloadMenu(false); cancelDownloadRef.current = false;
                let filesToDownload = []; let locationName = "";
                let scopePhotos = [];
                if (currentFolderId && currentFolderId.trim() !== "") {
                    const folder = driveFolders.find(f => f.id === currentFolderId);
                    if (folder) { scopePhotos = photos.filter(p => p.folderName === folder.name); locationName = `th∆∞ m·ª•c "${folder.name}"`; } else { scopePhotos = photos; locationName = "to√†n b·ªô Album"; }
                } else { scopePhotos = photos; locationName = "to√†n b·ªô Album"; }

                if (type === 'SELECTED') { filesToDownload = scopePhotos.filter(p => p.isSelected); locationName += " (ƒê√£ ch·ªçn)"; } else { filesToDownload = scopePhotos; }
                if (filesToDownload.length === 0) { return showToast(`Kh√¥ng t√¨m th·∫•y ·∫£nh n√†o trong ${locationName}!`, "warning"); }

                const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|Opera Mini|Mobile/i.test(navigator.userAgent);
                if (!isMobileDevice && 'showDirectoryPicker' in window) {
                    if (!window.confirm(`üíª CH·∫æ ƒê·ªò PC:\nB·∫°n s·∫Øp t·∫£i ${filesToDownload.length} ·∫£nh v·ªÅ m√°y t√≠nh (${locationName}).\nH·ªá th·ªëng s·∫Ω y√™u c·∫ßu b·∫°n ch·ªçn m·ªôt th∆∞ m·ª•c ƒë·ªÉ l∆∞u.`)) return;
                    setIsMovingFiles(true); setMoveProgress({ current: 0, total: filesToDownload.length, fileName: 'ƒêang kh·ªüi t·∫°o...' });
                    try {
                        const rootHandle = await window.showDirectoryPicker();
                        let successCount = 0;
                        for (let i = 0; i < filesToDownload.length; i++) {
                            if (cancelDownloadRef.current) { showToast("ƒê√£ h·ªßy qu√° tr√¨nh t·∫£i.", "warning"); break; }
                            const photo = filesToDownload[i];
                            setMoveProgress({ current: i + 1, total: filesToDownload.length, fileName: photo.name });
                            try {
                                let targetUrl = photo.originalUrl;
                                if (photo.isFromDrive && photo.originalUrl && !photo.originalUrl.includes('key=')) { targetUrl += `&key=${driveApiKey}`; }
                                const response = await fetch(targetUrl); if (!response.ok) throw new Error(`HTTP ${response.status}`);
                                const blob = await response.blob();
                                const safeFolderName = (photo.folderName || "Khac").replace(/[:\/\\?*|"><]/g, "_");
                                const folderHandle = await rootHandle.getDirectoryHandle(safeFolderName, { create: true });
                                const safeFileName = photo.name.replace(/[:\/\\?*|"><]/g, "_");
                                const fileHandle = await folderHandle.getFileHandle(safeFileName, { create: true });
                                const writable = await fileHandle.createWritable();
                                await writable.write(blob); await writable.close();
                                successCount++;
                            } catch (err) { console.error(`L·ªói l∆∞u ${photo.name}:`, err); }
                        }
                        if (successCount > 0) { showToast(`‚úÖ PC: ƒê√£ l∆∞u ${successCount}/${filesToDownload.length} ·∫£nh v√†o th∆∞ m·ª•c!`, 'success'); } else { showToast("‚ö†Ô∏è Kh√¥ng l∆∞u ƒë∆∞·ª£c ·∫£nh n√†o.", "error"); }
                    } catch (err) { if (err.name !== 'AbortError') showToast("L·ªói PC: " + err.message, "error"); } finally { setIsMovingFiles(false); setMoveProgress({ current: 0, total: 0, fileName: '' }); }
                } else {
                    alert("üì± TH√îNG B√ÅO QUAN TR·ªåNG:\n\n" + `B·∫°n ƒëang ch·ªçn t·∫£i ${filesToDownload.length} ·∫£nh.\n\n` + "Ch·ª©c nƒÉng t·∫£i h√†ng lo·∫°t CH·ªà H·ªñ TR·ª¢ TR√äN M√ÅY T√çNH (PC/Laptop).");
                }
            };

            const handleSingleDownload = useCallback((photo) => {
                if (!photo) return;
                try {
                    const isDownloaded = downloadedIds.has(photo.id); const msg = isDownloaded ? `ƒêang t·∫£i l·∫°i: ${photo.name}...` : `ƒêang x·ª≠ l√Ω: ${photo.name}...`; showToast(msg, 'info');
                    if (photo.originalFile) { saveAs(photo.originalFile, photo.name); showToast(`‚úÖ ƒê√£ l∆∞u: ${photo.name}`, 'success'); markAsDownloaded(photo.id); return; } 
                    let downloadUrl = ""; if (photo.isFromDrive) { downloadUrl = `https://drive.google.com/uc?export=download&id=${photo.id}`; downloadUrl += `&t=${Date.now()}`; } else { downloadUrl = photo.originalUrl || photo.url; }
                    const ua = navigator.userAgent; const isiOS = /iPhone|iPad|iPod/i.test(ua);
                    if (isiOS) { const tab = window.open(downloadUrl, '_blank'); if (tab) { setTimeout(() => { try { tab.close() } catch{} }, 2000); } } else { const iframe = document.createElement('iframe'); iframe.style.display = 'none'; iframe.src = downloadUrl; document.body.appendChild(iframe); setTimeout(() => { try { document.body.removeChild(iframe); } catch {} }, 60000); }
                    markAsDownloaded(photo.id); showToast(`‚úÖ ƒê√£ g·ª≠i l·ªánh t·∫£i. H√£y ki·ªÉm tra m√°y.`, 'success');
                } catch (error) { console.error(error); showToast("‚ùå L·ªói khi t·∫£i ·∫£nh", "error"); }
            }, [downloadedIds, markAsDownloaded, driveApiKey]); 

            const [isInitialized, setIsInitialized] = useState(false); 
            const [showPasscodeModal, setShowPasscodeModal] = useState(true); 
            const [passcodeError, setPasscodeError] = useState(false);
            const [isPasscodeVerified, setIsPasscodeVerified] = useState(false); 
            const [isLoading, setIsLoading] = useState(true); 
            const [showAdminPanel, setShowAdminPanel] = useState(false); 
            
            const showToast = useCallback((message, type = 'success') => { setNotification({ message, type }); setTimeout(() => setNotification(null), 3000); }, []);
            const logActivity = (type, details, metadata = {}) => { console.log(`[${viewMode}] ${type}:`, details, metadata); };

            useEffect(() => {
                if (!albumKey) return;
                const photosRef = db.ref(`albums/${albumKey}/current_status/photos`);
                const configRef = db.ref(`albums/${albumKey}/config`);
                const savedPasscode = sessionStorage.getItem(`lensflow_passcode_${albumKey}`);
                const adminToken = localStorage.getItem(`lensflow_admin_token_${albumKey}`);
                let photosListener = null;

                const setupAuthenticatedSession = (configData) => {
                    setShowPasscodeModal(false); setIsPasscodeVerified(true);
                    setAlbumName(configData.albumName || 'Ch∆∞a ƒë·∫∑t t√™n'); setDriveFolders(configData.driveFolders || []); setDriveApiKey(configData.driveApiKey || ''); setAdminPassword(configData.adminPassword || ''); setAllowComments(configData.allowComments !== undefined ? configData.allowComments : true);
                    if (!photosListener) {
                        photosListener = photosRef.on('value', (snapshot) => {
                            if (!snapshot.exists()) return;
                            const photosObject = snapshot.val(); let photosArray = objectToArray(photosObject);
                            photosArray.sort(compareDateTaken); setPhotos(photosArray); setLastSaveTime(new Date());
                        }, (error) => { console.error("Firebase Photos Read Error:", error); showToast("‚ùå L·ªói t·∫£i d·ªØ li·ªáu ·∫£nh t·ª´ Cloud!", 'error'); });
                    }
                };

                configRef.once('value').then((snapshot) => {
                    const configData = snapshot.val();
                    if (configData && configData.passcode) {
                        setIsInitialized(true);
                        if (adminToken && adminToken === configData.adminPassword) { setIsAuthenticated(true); setViewMode('PHOTOGRAPHER'); setupAuthenticatedSession(configData); showToast("Ch√†o m·ª´ng Admin tr·ªü l·∫°i!", 'success'); } 
                        else if (savedPasscode && savedPasscode === configData.passcode) { setupAuthenticatedSession(configData); } else { setShowPasscodeModal(true); setIsPasscodeVerified(false); localStorage.removeItem(`lensflow_admin_token_${albumKey}`); }
                    } else { setIsInitialized(false); setShowPasscodeModal(true); setIsAuthenticated(true); setViewMode('PHOTOGRAPHER'); }
                    setIsLoading(false);
                }).catch(error => { console.error("Firebase Config Read Error:", error); setIsLoading(false); });
                return () => { if (photosListener) { photosRef.off('value', photosListener); } }; 
            }, [albumKey, isPasscodeVerified]);

            useEffect(() => { document.title = `${albumName} - LensFlow`; }, [albumName]);

			const saveConfigToFirebase = useCallback(() => {
				if (!albumKey || viewMode !== 'PHOTOGRAPHER' || !adminPassword) return; 
				db.ref(`albums/${albumKey}/config/passcode`).once('value').then(snapshot => {
                    const currentPasscode = snapshot.val(); 
                    const configData = { driveFolders, driveApiKey, adminPassword, allowComments, albumName, passcode: currentPasscode };
                    db.ref(`albums/${albumKey}/config`).set(configData).then(() => console.log('‚úÖ Config saved')).catch(err => console.error('‚ùå Failed to save config:', err));
                }).catch(err => console.error('‚ùå Failed to read passcode:', err));
			}, [albumKey, driveFolders, driveApiKey, adminPassword, allowComments, albumName, viewMode]);

            useEffect(() => { const timer = setTimeout(() => saveConfigToFirebase(), 1000); return () => clearTimeout(timer); }, [driveFolders, driveApiKey, adminPassword, allowComments, saveConfigToFirebase]);

            const toggleSelect = useCallback((id) => {
                setPhotos(prevPhotos => {
                    const index = prevPhotos.findIndex(p => p.id === id); if (index === -1) return prevPhotos;
                    const p = prevPhotos[index]; const newState = !p.isSelected;
                    db.ref(`albums/${albumKey}/current_status/photos/${id}`).update({ isSelected: newState }).catch(console.error);
                    const newPhotos = [...prevPhotos]; newPhotos[index] = { ...p, isSelected: newState }; return newPhotos;
                });
            }, [albumKey]);

            const updateComment = useCallback((id, comment) => {
                setPhotos(prevPhotos => {
                    const index = prevPhotos.findIndex(p => p.id === id); if (index === -1) return prevPhotos;
                    const newPhotos = [...prevPhotos]; newPhotos[index] = { ...prevPhotos[index], comments: comment }; return newPhotos;
                });
                db.ref(`albums/${albumKey}/current_status/photos/${id}`).update({ comments: comment }).catch(console.error);
            }, [albumKey]);
            
            const handleFileUpload = async (e) => {
                const files = e.target.files;
                if (files) {
                    showToast("ƒêang x·ª≠ l√Ω ·∫£nh thumbnail...", "warning");
                    const resizeImage = (file, maxSize = 500) => new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.onload = () => {
                                const canvas = document.createElement('canvas'); let { width, height } = img;
                                if (width > height) { if (width > maxSize) { height *= maxSize / width; width = maxSize; } } else { if (height > maxSize) { width *= maxSize / height; height = maxSize; } }
                                canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, width, height); canvas.toBlob(resolve, 'image/jpeg', 0.8);
                            }; img.src = event.target.result;
                        }; reader.readAsDataURL(file);
                    });
                    const getDateTaken = (file) => new Promise((resolve) => { try { EXIF.getData(file, function() { let date = EXIF.getTag(this, 'DateTimeOriginal') || EXIF.getTag(this, 'DateTime'); if (date) { const parts = date.split(' '); if (parts.length === 2) { const d = parts[0].replace(/:/g, '-'); resolve(`${d}T${parts[1]}`); } else { resolve(date); } } else { resolve(null); } }); } catch { resolve(null); } });
                    const photoPromises = Array.from(files).map(async (file) => {
                        const thumbnailBlob = await resizeImage(file); const dateTaken = await getDateTaken(file);
                        return { id: Math.random().toString(36).substr(2, 9), url: URL.createObjectURL(thumbnailBlob), originalUrl: URL.createObjectURL(file), name: file.name, isSelected: false, comments: '', isFromDrive: false, originalFile: file, dateTaken };
                    });
                    const newPhotos = await Promise.all(photoPromises);
                    const photosObject = arrayToObject(newPhotos);
                    db.ref(`albums/${albumKey}/current_status/photos`).set(photosObject).then(() => { showToast(`‚úÖ ƒê√£ th√™m ${newPhotos.length} ·∫£nh v√† ƒë·ªìng b·ªô!`); setPhotos(newPhotos); }).catch(error => showToast(`L·ªói t·∫£i l√™n Firebase: ${error.message}`, 'error'));
                }
            };

			const syncDataToFirebase = (newPhotosArray, currentFolders, currentApiKey) => {
				return db.ref(`albums/${albumKey}/config/passcode`).once('value').then(snapshot => {
                    const currentPasscode = snapshot.val();
                    const configData = { driveFolders: currentFolders, driveApiKey: currentApiKey, adminPassword: adminPassword, allowComments: allowComments, albumName, passcode: currentPasscode };
                    const photosObject = arrayToObject(newPhotosArray); const updates = {};
                    updates[`albums/${albumKey}/current_status/photos`] = photosObject; updates[`albums/${albumKey}/config`] = configData;
                    return db.ref().update(updates);
                });
			};

            const syncAllFolders = async () => {
                if (!driveApiKey) { showToast("Thi·∫øu API Key", "error"); return; }
                const validFolders = driveFolders.filter(f => f.id && f.id.trim());
                if (validFolders.length === 0) { showToast("Ch∆∞a c√≥ Folder ID h·ª£p l·ªá", "error"); return; }
                const existingSelections = photos.filter(p => p.isSelected || p.comments);
                if (existingSelections.length > 0) { const confirm = window.confirm(`B·∫°n ƒë√£ c√≥ ${existingSelections.length} ·∫£nh ƒë√£ ch·ªçn/comment.\n\n` + `CH·ªåN "OK" ƒë·ªÉ GI·ªÆ l·ª±a ch·ªçn c≈© v√† sync l·∫°i danh s√°ch.\n` + `CH·ªåN "Cancel" ƒë·ªÉ h·ªßy b·ªè.`); if (!confirm) return; }
                setIsSyncingDrive(true); setSyncProgress({ current: 0, total: 0, folderName: 'ƒêang k·∫øt n·ªëi API...' });
                try {
                    let allPhotosFromAllFolders = []; const existingMap = new Map(photos.map(p => [p.id, p]));
                    for (let i = 0; i < validFolders.length; i++) {
                        const folder = validFolders[i]; setSyncProgress({ current: 0, total: 0, folderName: `ƒêang qu√©t: ${folder.name}` });
                        let folderFiles = []; let pageToken = null;
                        do {
                            let url = `https://www.googleapis.com/drive/v3/files?q='${folder.id}'+in+parents+and+mimeType+contains+'image/'&fields=nextPageToken,files(id,name,thumbnailLink,webContentLink,createdTime,imageMediaMetadata)&key=${driveApiKey}&pageSize=100`;
                            if (pageToken) url += `&pageToken=${pageToken}`;
                            const res = await fetch(url); const data = await res.json();
                            if (data.error) throw new Error(`${folder.name}: ${data.error.message}`);
                            if (data.files && data.files.length > 0) {
                                const processedFiles = data.files.map(f => {
                                    let dateTaken = null;
                                    if (f.imageMediaMetadata && f.imageMediaMetadata.time) { const parts = f.imageMediaMetadata.time.split(' '); if (parts.length === 2) { dateTaken = parts[0].replace(/:/g, '-') + 'T' + parts[1]; } else { dateTaken = f.imageMediaMetadata.time; } } else if (f.createdTime) { dateTaken = f.createdTime; }
                                    const existing = existingMap.get(f.id);
                                    return { id: f.id, url: `https://drive.google.com/thumbnail?id=${f.id}&sz=w300`, lightboxUrl: `https://drive.google.com/thumbnail?id=${f.id}&sz=w1600`, originalUrl: `https://www.googleapis.com/drive/v3/files/${f.id}?alt=media&key=${driveApiKey}`, name: f.name, folderName: folder.name, isSelected: existing?.isSelected || false, comments: existing?.comments || '', isFromDrive: true, dateTaken: dateTaken };
                                });
                                folderFiles = [...folderFiles, ...processedFiles];
                            }
                            pageToken = data.nextPageToken;
                        } while (pageToken);
                        allPhotosFromAllFolders = [...allPhotosFromAllFolders, ...folderFiles]; showToast(`‚úÖ ${folder.name}: ƒê√£ t√¨m th·∫•y ${folderFiles.length} ·∫£nh`, 'success');
                    }
                    setSyncProgress({ current: 100, total: 100, folderName: 'ƒêang s·∫Øp x·∫øp & L∆∞u...' });
                    allPhotosFromAllFolders.sort(compareDateTaken);
                    await syncDataToFirebase(allPhotosFromAllFolders, validFolders, driveApiKey);
                    showToast(`‚úÖ Ho√†n t·∫•t! ƒê√£ ƒë·ªìng b·ªô ${allPhotosFromAllFolders.length} ·∫£nh si√™u t·ªëc!`); logActivity('SYNC_ALL_FOLDERS', `Fast Sync: ${allPhotosFromAllFolders.length} items`);
                } catch (error) { console.error(error); showToast("L·ªói Sync: " + error.message, "error"); } finally { setIsSyncingDrive(false); setSyncProgress({ current: 0, total: 0, folderName: '' }); }
            };
            
            const handleSaveSnapshot = () => {
                const timestampKey = new Date().toISOString().replace(/\./g, '-');
                const photosObject = photos.reduce((acc, p) => { acc[p.id] = p; return acc; }, {});
                const snapshotData = { photos: photosObject, config: { driveFolders, allowComments, adminPassword, driveApiKey, albumName }, metadata: { timestamp: new Date().toLocaleString('vi-VN'), selectedCount: photos.filter(p => p.isSelected).length } };
                db.ref(`albums/${albumKey}/history/${timestampKey}`).set(snapshotData).then(() => showToast(`‚úÖ ƒê√£ l∆∞u Snapshot`, 'success')).catch(error => showToast(`L·ªói: ${error.message}`, 'error'));
            };
            
            const handleDownloadReport = () => {
                const selected = photos.filter(p => p.isSelected);
                if (!selected.length) { showToast("Ch∆∞a ch·ªçn ·∫£nh", "warning"); return; }
                let content = `B√ÅO C√ÅO - ${albumName.toUpperCase()}\nNg√†y: ${new Date().toLocaleString('vi-VN')}\nS·ªë l∆∞·ª£ng: ${selected.length}\n${'='.repeat(50)}\n\n`;
                const groupedByFolder = {};
                selected.forEach(p => { const folderName = p.folderName || 'Kh√¥ng r√µ th∆∞ m·ª•c'; if (!groupedByFolder[folderName]) { groupedByFolder[folderName] = []; } groupedByFolder[folderName].push(p); });
                Object.keys(groupedByFolder).forEach(folderName => {
                    content += `\n\n‚îå${'\u2500'.repeat(48)}\u2510\n‚îÇ  ${folderName.toUpperCase().padEnd(46)}‚îÇ\n‚îî${'\u2500'.repeat(48)}\u2518\n\n`;
                    groupedByFolder[folderName].forEach((p, i) => { const commentText = p.comments && p.comments.trim() ? p.comments : "(Kh√¥ng c√≥ ghi ch√∫)"; content += `${i + 1}. ${p.name}\n   ${commentText}\n${'='.repeat(50)}\n`; });
                });
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' }); const link = document.createElement('a');
                const filename = `Order_${albumName.replace(/\s+/g, '_')}.txt`; link.download = filename; link.href = URL.createObjectURL(blob); document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(link.href); showToast("ƒê√£ xu·∫•t file!", 'success');
            };

            const handleMoveToFinal = async () => {
                const selected = photos.filter(p => p.isSelected); if (!selected.length) { showToast("Ch∆∞a c√≥ ·∫£nh n√†o ƒë∆∞·ª£c ch·ªçn", "warning"); return; }
                setIsMovingFiles(true); setMoveProgress({ current: 0, total: selected.length, fileName: '' });
                if ('showDirectoryPicker' in window) {
                    try {
                        const dirHandle = await window.showDirectoryPicker(); let successCount = 0; let failCount = 0;
                        for (let i = 0; i < selected.length; i++) {
                            const photo = selected[i]; setMoveProgress({ current: i + 1, total: selected.length, fileName: photo.name });
                            try {
                                let blob;
                                if (photo.originalFile) { blob = photo.originalFile; } 
                                else if (photo.isFromDrive && photo.originalUrl) { const response = await fetch(photo.originalUrl); if (!response.ok) throw new Error(`L·ªói`); blob = await response.blob(); }
                                else { const response = await fetch(photo.url); if (!response.ok) throw new Error("L·ªói"); blob = await response.blob(); }
                                const fileHandle = await dirHandle.getFileHandle(photo.name, { create: true }); const writable = await fileHandle.createWritable(); await writable.write(blob); await writable.close(); successCount++;
                            } catch (err) { failCount++; }
                        }
                        setMoveProgress({ current: 0, total: 0, fileName: '' }); showToast(`‚úÖ ƒê√£ l∆∞u ${successCount}/${selected.length} ·∫£nh!`, 'success');
                    } catch (err) { if (err.name !== 'AbortError') { showToast("L·ªói: " + err.message, "error"); } setMoveProgress({ current: 0, total: 0, fileName: '' }); }
                } else {
                    showToast("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ ch·ªçn folder. ƒêang t·∫£i xu·ªëng t·ª´ng file...", "warning");
                    for (let i = 0; i < selected.length; i++) {
                        const photo = selected[i]; setMoveProgress({ current: i + 1, total: selected.length, fileName: photo.name });
                        const downloadUrl = photo.originalUrl || photo.url; await new Promise(resolve => setTimeout(resolve, 300));
                        const link = document.createElement('a'); link.href = downloadUrl; link.download = photo.name; document.body.appendChild(link); link.click(); document.body.removeChild(link);
                    }
                    setMoveProgress({ current: 0, total: 0, fileName: '' }); showToast(`ƒê√£ t·∫£i ${selected.length} ·∫£nh!`, 'success');
                }
                setIsMovingFiles(false);
            };

            const handleInitializeAlbum = (adminPasswordInput, newPasscodeInput) => {
                if (adminPasswordInput.length < 4 || newPasscodeInput.length < 4) { setPasscodeError("M·∫≠t kh·∫©u Admin v√† Passcode Kh√°ch h√†ng ph·∫£i c√≥ √≠t nh·∫•t 4 k√Ω t·ª±."); return; }
                localStorage.setItem(`lensflow_admin_token_${albumKey}`, adminPasswordInput);
                const configData = { driveFolders: [], driveApiKey: '', adminPassword: adminPasswordInput, allowComments: true, passcode: newPasscodeInput, albumName };
                const updates = {}; updates[`albums/${albumKey}/config`] = configData; updates[`albums/${albumKey}/current_status/photos`] = {}; 
                db.ref().update(updates).then(() => {
                    sessionStorage.setItem(`lensflow_passcode_${albumKey}`, newPasscodeInput);
                    setAdminPassword(adminPasswordInput); setIsInitialized(true); setIsPasscodeVerified(true); setShowPasscodeModal(false); setIsAuthenticated(true); setViewMode('PHOTOGRAPHER'); 
                    const photosRef = db.ref(`albums/${albumKey}/current_status/photos`);
                    photosRef.on('value', (snapshot) => { if (!snapshot.exists()) return; const photosObject = snapshot.val(); const photosArray = objectToArray(photosObject); setPhotos(photosArray); setLastSaveTime(new Date()); });
                    showToast("‚úÖ Kh·ªüi t·∫°o th√†nh c√¥ng!", 'success');
                }).catch(err => { console.error(err); setPasscodeError("L·ªói Firebase."); });
            };

            const handlePasscodeAccess = async (inputPasscode) => {
                setPasscodeError(false);
                try {
                    const snapshot = await db.ref(`albums/${albumKey}/config`).once('value'); const configData = snapshot.val();
                    if (configData && inputPasscode === configData.passcode) {
                        sessionStorage.setItem(`lensflow_passcode_${albumKey}`, inputPasscode);
                        setAlbumName(configData.albumName || 'Ch∆∞a ƒë·∫∑t t√™n'); setDriveFolders(configData.driveFolders || []); setDriveApiKey(configData.driveApiKey || ''); setAdminPassword(configData.adminPassword || ''); setAllowComments(configData.allowComments !== undefined ? configData.allowComments : true);
                        setShowPasscodeModal(false); setIsPasscodeVerified(true); setViewMode('CLIENT'); showToast("‚úÖ Truy c·∫≠p th√†nh c√¥ng!");
                    } else { setPasscodeError(true); }
                } catch(e) { setPasscodeError(true); }
            };

            const handleLogin = () => {
                if (adminPassword && passwordInput === adminPassword) { setIsAuthenticated(true); setShowLoginModal(false); setLoginError(false); setPasswordInput(""); localStorage.setItem(`lensflow_admin_token_${albumKey}`, passwordInput); setViewMode('PHOTOGRAPHER'); setShowAdminPanel(true); setShowPasscodeModal(false); setIsPasscodeVerified(true); showToast("üîì ƒêƒÉng nh·∫≠p Admin th√†nh c√¥ng!", "success"); } else { setLoginError(true); showToast("M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng", "error"); }
            };

            const filteredPhotos = useMemo(() => {
                let result = photos;
                if (currentFolderId) { const folderName = driveFolders.find(f => f.id === currentFolderId)?.name; result = result.filter(p => p.folderName === folderName); }
                if (filterMode === 'SELECTED') { result = result.filter(p => p.isSelected); }
                return result;
            }, [photos, filterMode, currentFolderId, viewMode, driveFolders]);
            
            const selectedCount = useMemo(() => photos.filter(p => p.isSelected).length, [photos]);
            const viewStats = useMemo(() => {
                let baseFiltered = photos; if (currentFolderId) { const folderName = driveFolders.find(f => f.id === currentFolderId)?.name; baseFiltered = baseFiltered.filter(p => p.folderName === folderName); }
                const selectedInView = baseFiltered.filter(p => p.isSelected).length; const totalInView = baseFiltered.length;
                return { selected: selectedInView, total: totalInView };
            }, [photos, currentFolderId, driveFolders]);

            const selectedPhotoIndex = useMemo(() => { return selectedPhoto ? filteredPhotos.findIndex(p => p.id === selectedPhoto.id) : -1; }, [selectedPhoto, filteredPhotos]);
            
            const handlePhotoChange = useCallback((newPhoto) => {
                setSelectedPhoto(newPhoto);
                // --- [LOGIC M·ªöI] ƒê·ªìng b·ªô cu·ªôn ---
                if (gridRef.current && filteredPhotos.length > 0) {
                    const index = filteredPhotos.findIndex(p => p.id === newPhoto.id);
                    if (index !== -1) { gridRef.current.scrollToItem(index); }
                }
            }, [filteredPhotos]);

            return (
                <div className="flex h-screen bg-gray-50 text-gray-900 overflow-hidden">
                    {notification && (
                        <div className={`fixed top-4 left-1/2 -translate-x-1/2 z-[100] px-6 py-3 rounded-full shadow-2xl flex items-center gap-2 border ${notification.type === 'success' ? 'bg-green-50 border-green-500 text-green-700' : notification.type === 'error' ? 'bg-red-50 border-red-500 text-red-700' : 'bg-yellow-50 border-yellow-500 text-yellow-700'}`}>
                            {notification.type === 'success' ? <Icon name="check" size={18} /> : <Icon name="alert" size={18} />} <span className="text-sm font-medium">{notification.message}</span>
                        </div>
                    )}
                    {isLoading && (<div className="fixed inset-0 z-[110] bg-gray-50 flex items-center justify-center text-pink-500"><Icon name="loader" size={40} /><span className="ml-3 text-lg text-gray-500">ƒêang t·∫£i c·∫•u h√¨nh...</span></div>)}
                    {showPasscodeModal && !isLoading && (<PasscodeModal isInitialized={isInitialized} onAccess={handlePasscodeAccess} onInitialize={handleInitializeAlbum} error={passcodeError} albumKey={albumKey} />)}
                    {showLoginModal && (
                        <div className="fixed inset-0 bg-gray-900/50 backdrop-blur-sm z-[60] flex items-center justify-center p-4">
                            <div className="bg-white border border-gray-200 p-8 rounded-2xl max-w-sm w-full shadow-xl">
                                <div className="flex justify-center mb-6 text-pink-500"><Icon name="lock" size={48} /></div>
                                <h2 className="text-xl font-bold text-center mb-4 text-gray-900">Qu·∫£n tr·ªã vi√™n</h2>
                                <input type="password" autoFocus value={passwordInput} onChange={(e) => setPasswordInput(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && handleLogin()} placeholder="M·∫≠t kh·∫©u..." className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded-lg px-4 py-3 focus:border-pink-500 outline-none mb-4" />
                                {loginError && <p className="text-red-500 text-xs text-center mb-4">Sai m·∫≠t kh·∫©u</p>}
                                <div className="flex gap-3"><button onClick={() => setShowLoginModal(false)} className="flex-1 py-2 rounded-lg border border-gray-200 text-gray-600 hover:bg-gray-100">H·ªßy</button><button onClick={handleLogin} className="flex-1 py-2 rounded-lg bg-pink-500 hover:bg-pink-400 text-white font-bold shadow-lg shadow-pink-500/20">ƒêƒÉng nh·∫≠p</button></div>
                            </div>
                        </div>
                    )}
                    {isMovingFiles && moveProgress.total > 0 && (
                        <div className="fixed inset-0 bg-gray-900/50 backdrop-blur-sm z-[70] flex items-center justify-center p-4">
                            <div className="bg-white border border-gray-200 p-8 rounded-2xl max-w-md w-full shadow-xl">
                                <div className="flex justify-center mb-4 text-green-500"><Icon name="loader" size={48} /></div>
                                <h2 className="text-lg font-bold text-center mb-6 text-gray-900">ƒêang ƒë·ªìng b·ªô ·∫£nh t·ª´ Google Drive...</h2>
                                <div className="mb-4">
                                    <div className="flex justify-between text-sm mb-2"><span className="text-gray-500">Ti·∫øn tr√¨nh:</span><span className="text-green-600 font-bold">{syncProgress.current}/{syncProgress.total} ({syncProgress.percent || 0}%)</span></div>
                                    <div className="w-full bg-gray-100 rounded-full h-1.5"><div className="bg-gradient-to-r from-green-500 to-emerald-500 h-full transition-all duration-300" style={{ width: `${syncProgress.percent || 0}%` }}></div></div>
                                </div>
                                <div className="bg-gray-50 p-3 rounded-lg border border-gray-200 mb-6">
                                    <p className="text-xs text-gray-400 mb-1">ƒêang x·ª≠ l√Ω ·∫£nh:</p><p className="text-sm text-gray-800 truncate font-mono">{syncProgress.fileName || ""}</p><p className="text-xs text-gray-500 mt-2">Th∆∞ m·ª•c: <span className="font-bold">{syncProgress.folderName || ""}</span></p>
                                </div>
                                <button onClick={() => { cancelDownloadRef.current = true; }} className="w-full py-2.5 rounded-lg border border-red-200 text-red-600 font-bold hover:bg-red-50 transition-colors flex items-center justify-center gap-2"><Icon name="x" size={18} />H·ªßy b·ªè</button>
                            </div>
                        </div>
                    )}

                    {isPasscodeVerified && (
                        <>
                            {showAdminPanel && viewMode === 'PHOTOGRAPHER' && (<div className="fixed inset-0 bg-black/20 z-30 md:hidden" onClick={() => setShowAdminPanel(false)}></div>)}
                            <div className={`fixed md:relative top-0 left-0 h-full z-40 md:z-auto transition-all duration-300 ease-in-out bg-white border-r border-gray-200 overflow-hidden flex-shrink-0 w-80 ${viewMode === 'PHOTOGRAPHER' ? 'md:w-80' : 'md:w-0'} ${showAdminPanel ? 'translate-x-0' : '-translate-x-full'} md:translate-x-0 shadow-xl md:shadow-none`}>
                                <div className="p-6 overflow-y-auto h-full">
                                    <div className="flex items-center justify-between gap-2 text-pink-500 mb-8"><Icon name="camera" size={28} /><span className="font-bold text-xl text-gray-900">Admin Panel</span><button onClick={() => setShowAdminPanel(false)} className="md:hidden p-2 text-gray-400 hover:text-gray-600"><Icon name="x" size={20} /></button></div>
                                    <div className="mb-6">
                                        <h3 className="text-xs font-bold text-gray-400 uppercase mb-3 flex items-center gap-2"><Icon name="settings" size={12} /> C√†i ƒë·∫∑t</h3>
                                        <input type="text" value={albumName} onChange={(e) => setAlbumName(e.target.value)} placeholder="T√™n Album" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded px-3 py-2 text-sm mb-3 focus:border-pink-500 outline-none"/>
                                        <div className="flex items-center justify-between bg-gray-50 p-3 rounded-lg border border-gray-200"><div className="flex items-center gap-2 text-sm text-gray-700">{allowComments ? <Icon name="messageOn" size={16} className="text-green-500" /> : <Icon name="messageOff" size={16} className="text-red-400" />}<span>B√¨nh lu·∫≠n</span></div><button onClick={() => setAllowComments(!allowComments)} className={`w-10 h-5 rounded-full relative ${allowComments ? 'bg-green-500' : 'bg-gray-300'}`}><div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-all shadow-sm ${allowComments ? 'left-6' : 'left-1'}`} /></button></div>
                                        <input type="password" value={adminPassword} onChange={(e) => setAdminPassword(e.target.value)} placeholder="Admin Password" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded px-3 py-2 text-sm mt-3 focus:border-pink-500 outline-none"/>
                                    </div>
                                    <div className="mb-6">
                                        <h3 className="text-xs font-bold text-gray-400 uppercase mb-3 flex items-center gap-2"><Icon name="cloud" size={12} /> Google Drive Folders</h3>
                                        <input type="password" value={driveApiKey} onChange={(e) => setDriveApiKey(e.target.value)} placeholder="API Key" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded px-3 py-2 text-xs mb-3 focus:border-pink-500 outline-none"/>
                                        <div className="space-y-2 mb-3 max-h-40 overflow-y-auto">
                                            {driveFolders.map((folder, idx) => (
                                                <div key={idx} className="flex gap-2 items-center bg-gray-50 p-2 rounded border border-gray-200">
                                                    <input type="text" value={folder.name} onChange={(e) => {const newFolders = [...driveFolders];newFolders[idx].name = e.target.value;setDriveFolders(newFolders);}} placeholder="T√™n" className="w-20 bg-white border border-gray-200 rounded px-2 py-1 text-xs focus:border-pink-500 outline-none text-gray-800"/>
                                                    <input type="text" value={folder.id} onChange={(e) => {const newFolders = [...driveFolders];newFolders[idx].id = e.target.value;setDriveFolders(newFolders);}} placeholder="Folder ID" className="flex-1 bg-white border border-gray-200 rounded px-2 py-1 text-xs focus:border-pink-500 outline-none text-gray-800"/>
                                                    <button onClick={() => setDriveFolders(driveFolders.filter((_, i) => i !== idx))} className="p-1.5 bg-red-50 text-red-500 hover:bg-red-100 rounded"><Icon name="x" size={12} /></button>
                                                </div>
                                            ))}
                                        </div>
                                        <button onClick={() => setDriveFolders([...driveFolders, {name: '', id: ''}])} className="w-full py-1.5 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded text-xs mb-3 flex items-center justify-center gap-1 transition-colors"><span className="text-lg leading-none">+</span> Th√™m folder</button>
                                        {driveFolders.length > 0 && (<button onClick={syncAllFolders} disabled={isSyncingDrive} className="w-full py-2 bg-pink-50 hover:bg-pink-100 text-pink-600 border border-pink-200 rounded-lg text-xs font-bold flex items-center justify-center gap-2 disabled:opacity-50 mb-3 transition-colors">{isSyncingDrive ? <><Icon name="loader" size={14} /> ƒêang sync...</> : <><Icon name="refresh" size={14} /> Sync T·∫•t C·∫£ ({driveFolders.filter(f => f.id).length})</>}</button>)}
                                        {driveFolders.length > 0 && (<div className="space-y-2"><label className="text-[10px] text-gray-400 uppercase font-semibold">Xem tr∆∞·ªõc:</label><select value={currentFolderId} onChange={(e) => {const newFolderId = e.target.value;setCurrentFolderId(newFolderId);}} className="w-full bg-gray-50 border border-gray-200 text-gray-800 rounded px-2 py-2 text-xs focus:border-pink-500 outline-none"><option value="">T·∫•t c·∫£ th∆∞ m·ª•c</option>{driveFolders.map((folder, idx) => (<option key={idx} value={folder.id}>{folder.name || `Folder ${idx + 1}`}</option>))}</select></div>)}
                                    </div>
                                    <div className="mb-6"><h3 className="text-xs font-bold text-gray-400 uppercase mb-3 flex items-center gap-2"><Icon name="shield" size={12} /> Cloud Storage (Firebase)</h3><button onClick={handleSaveSnapshot} className="w-full py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg text-xs font-medium flex items-center justify-center gap-1 shadow-md shadow-blue-200"><Icon name="download" size={14} /> Save Snapshot</button></div>
                                    <div className="mb-6"><h3 className="text-xs font-bold text-gray-400 uppercase mb-3 flex items-center gap-2"><Icon name="upload" size={12} /> Upload Local</h3><label className="flex flex-col items-center justify-center w-full h-16 border-2 border-gray-300 border-dashed rounded-xl hover:bg-gray-50 hover:border-pink-300 cursor-pointer group transition-all"><Icon name="folder" size={24} className="text-gray-400 group-hover:text-pink-500 transition-colors" /><span className="text-[10px] text-gray-500 mt-1">Ch·ªçn ·∫£nh</span><input type="file" className="hidden" multiple accept="image/*" onChange={handleFileUpload} /></label></div>
                                    <div className="space-y-3 border-t border-gray-100 pt-6"><div className="flex justify-between text-sm"><span className="text-gray-500">ƒê√£ ch·ªçn:</span><span className="font-bold text-pink-500">{selectedCount} ·∫£nh</span></div><button onClick={() => setFilterMode(filterMode === 'ALL' ? 'SELECTED' : 'ALL')} className={`w-full py-2 rounded-lg text-xs font-medium flex items-center justify-center gap-2 ${filterMode === 'SELECTED' ? 'bg-pink-500 text-white' : 'bg-gray-100 text-gray-600'}`}>{filterMode === 'SELECTED' ? <><Icon name="eye" size={14} /> Hi·ªán t·∫•t c·∫£</> : <><Icon name="filter" size={14} /> Xem ·∫£nh ch·ªçn</>}</button><button onClick={handleDownloadReport} disabled={!selectedCount} className="w-full py-3 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white rounded-lg text-xs font-bold disabled:opacity-50 flex items-center justify-center gap-2 shadow-lg shadow-indigo-200"><Icon name="download" size={16} /> Xu·∫•t Order (.txt)</button><button onClick={handleMoveToFinal} disabled={isMovingFiles || !selectedCount} className="w-full py-3 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white rounded-lg text-xs font-bold disabled:opacity-50 flex items-center justify-center gap-2 shadow-lg shadow-green-200">{isMovingFiles ? <><Icon name="loader" size={16} /> ƒêang l∆∞u...</> : <><Icon name="folder" size={16} /> L∆∞u v√†o Folder</>}</button></div>
                                </div>
                            </div>
                            <div className="flex-1 flex flex-col min-w-0 overflow-hidden relative w-full h-full">
                                <header className="h-16 border-b border-gray-200 bg-white shadow-sm z-10 shrink-0 px-3 md:px-4 grid grid-cols-[auto_minmax(0,1fr)_auto] gap-3 items-center">
                                    <div className="flex items-center gap-2 md:gap-3">
                                        {viewMode === 'PHOTOGRAPHER' && (<button onClick={() => setShowAdminPanel(true)} className="md:hidden -ml-1 p-2 text-gray-500 hover:text-gray-800"><Icon name="menu" size={24} /></button>)}
                                        <div className="relative z-50">
                                            <button onClick={() => setShowDownloadMenu(!showDownloadMenu)} className={`w-10 h-10 rounded-xl flex-shrink-0 flex items-center justify-center shadow-lg transition-all active:scale-95 ${showDownloadMenu ? 'bg-pink-600 text-white ring-2 ring-pink-300' : 'bg-gradient-to-br from-pink-500 to-purple-600 text-white shadow-pink-200'}`}><Icon name="camera" size={20} stroke="white" />{viewStats.selected > 0 && (<div className="absolute -top-1 -right-1 bg-white text-pink-600 text-[10px] font-bold w-4 h-4 rounded-full flex items-center justify-center shadow-sm border border-pink-100">{viewStats.selected > 9 ? '9+' : viewStats.selected}</div>)}</button>
                                            {showDownloadMenu && (<>{/* ... Dropdown menu code ... */}<div className="fixed inset-0 z-40" onClick={() => setShowDownloadMenu(false)}></div><div className="absolute top-12 left-0 w-72 bg-white rounded-xl shadow-2xl border border-gray-100 z-50 overflow-hidden animate-in fade-in zoom-in-95 duration-200 origin-top-left"><div className="bg-gray-50 px-4 py-3 border-b border-gray-100"><p className="text-[10px] font-bold text-gray-400 uppercase tracking-wider">T·∫£i v·ªÅ m√°y (Original)</p><p className="text-xs font-bold text-pink-600 truncate">Ph·∫°m vi: {currentFolderId ? (driveFolders.find(f => f.id === currentFolderId)?.name || "Th∆∞ m·ª•c hi·ªán t·∫°i") : "To√†n b·ªô Album"}</p></div><div className="p-2 space-y-1"><button onClick={() => handleSmartDownload('SELECTED')} disabled={viewStats.selected === 0} className="w-full text-left px-3 py-3 hover:bg-pink-50 rounded-lg flex items-center gap-3 transition-colors disabled:opacity-40 disabled:cursor-not-allowed group"><div className="w-10 h-10 rounded-full bg-pink-100 text-pink-600 group-disabled:bg-gray-100 group-disabled:text-gray-400 flex items-center justify-center flex-shrink-0"><Icon name="heart" size={18} fill="currentColor" /></div><div><p className="text-sm font-bold text-gray-800 group-disabled:text-gray-500">T·∫£i ·∫£nh ƒê√£ ch·ªçn</p><p className="text-[10px] text-gray-500">{viewStats.selected} t·∫•m</p></div></button><button onClick={() => handleSmartDownload('ALL')} className="w-full text-left px-3 py-3 hover:bg-blue-50 rounded-lg flex items-center gap-3 transition-colors group"><div className="w-10 h-10 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center flex-shrink-0"><Icon name="folder" size={18} /></div><div><p className="text-sm font-bold text-gray-800">T·∫£i t·∫•t c·∫£ ·∫£nh</p><p className="text-[10px] text-gray-500">{currentFolderId ? "Ch·ªâ t·∫£i th∆∞ m·ª•c ƒëang xem" : "T·∫£i to√†n b·ªô album"}</p></div></button></div><div className="bg-yellow-50 px-4 py-2 text-[10px] text-yellow-700 border-t border-yellow-100 flex gap-2"><Icon name="alert" size={12} /><span>PC: L∆∞u v√†o folder ‚Ä¢ Mobile: T·∫£i t·ª´ng t·∫•m</span></div></div></>)}
                                        </div>
                                    </div>
                                    <div className="flex items-center gap-2 md:gap-3 overflow-hidden min-w-0 justify-start md:justify-center xl:justify-start">
                                        <h1 className="font-bold text-lg text-gray-800 truncate" title={albumName}>{albumName}</h1>
                                        {viewMode === 'CLIENT' && driveFolders.length > 0 && (<div className="hidden md:block flex-shrink-0"><select value={currentFolderId} onChange={(e) => {setCurrentFolderId(e.target.value);}} className="bg-gray-50 border border-gray-200 text-gray-700 rounded-lg px-3 py-2 text-sm focus:border-pink-500 outline-none cursor-pointer max-w-[120px] truncate h-9"><option value="">T·∫•t c·∫£</option>{driveFolders.map((folder, idx) => (<option key={idx} value={folder.id}>{folder.name}</option>))}</select></div>)}
                                        {viewMode === 'CLIENT' && viewStats.total > 0 && (<div className="hidden md:flex items-center gap-2 bg-gray-100 border border-gray-200 px-3 py-2 rounded-lg flex-shrink-0 h-9"><span className="font-bold text-pink-500">{viewStats.selected}</span><Icon name="heart" size={14} className="text-pink-500" fill="currentColor" /><span className="text-gray-400">/</span><span className="text-gray-500">{viewStats.total}</span></div>)}
                                        {lastSaveTime && (<span className="hidden md:flex text-[10px] text-green-600 items-center gap-1 bg-green-50 px-2 py-1 rounded-full" title="T·ª± ƒë·ªông ƒë·ªìng b·ªô l√™n Firebase"><Icon name="checkCircle" size={10} /> Sync: {lastSaveTime.toLocaleTimeString('vi-VN')}</span>)}
                                    </div>
                                    <div className="flex justify-end"><button onClick={() => {if (viewMode === 'PHOTOGRAPHER') {setViewMode('CLIENT');setShowAdminPanel(false);setIsAuthenticated(false); localStorage.removeItem(`lensflow_admin_token_${albumKey}`);setPasswordInput(""); showToast("ƒê√£ ƒëƒÉng xu·∫•t Admin", "info");} else {setShowLoginModal(true);}}} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-bold transition-all shadow-sm active:scale-95 whitespace-nowrap ${viewMode === 'PHOTOGRAPHER' ? 'bg-red-50 text-red-500 border border-red-200 hover:bg-red-100 hover:border-red-300' : 'bg-gray-800 text-white border border-gray-900 hover:bg-gray-700'}`}>{viewMode === 'PHOTOGRAPHER' ? (<><Icon name="logOut" size={16} /> <span className="hidden md:inline">Tho√°t</span></>) : (<><Icon name="lock" size={16} /> <span className="hidden md:inline">Admin</span></>)}</button></div>
                                </header>
                                {viewMode === 'CLIENT' && (<div className="md:hidden flex items-center gap-2 p-2 border-b border-gray-200 bg-white">{driveFolders.length > 0 && (<select value={currentFolderId} onChange={(e) => setCurrentFolderId(e.target.value)} className="flex-1 bg-gray-50 border border-gray-200 text-gray-800 rounded-lg px-3 py-2 text-sm focus:border-pink-500 outline-none"><option value="">T·∫•t c·∫£ th∆∞ m·ª•c</option>{driveFolders.map((folder, idx) => (<option key={idx} value={folder.id}>{folder.name}</option>))}</select>)}{viewStats.total > 0 && (<div className="flex items-center justify-center gap-2 bg-gray-50 border border-gray-200 px-3 py-2 rounded-lg"><span className="font-bold text-pink-500">{viewStats.selected}</span><Icon name="heart" size={14} className="text-pink-500" fill="currentColor" /><span className="text-gray-400">/</span><span className="text-gray-600">{viewStats.total}</span></div>)}</div>)}

                                <main className="flex-1 overflow-hidden relative md:p-4 bg-gray-50 w-full h-full">
                                    {!photos.length ? (
                                        <div className="h-full flex flex-col items-center justify-center text-gray-400 opacity-50"><Icon name="grid" size={64} strokeWidth={1} className="mb-4" /><p className="text-lg font-light">Ch∆∞a c√≥ ·∫£nh n√†o</p></div>
                                    ) : (
                                        <VirtualPhotoGrid
                                            ref={gridRef}
                                            photos={filteredPhotos} viewMode={viewMode} onToggleSelect={toggleSelect} onUpdateComment={updateComment} onOpenView={handlePhotoChange} allowComments={allowComments} downloadedIds={downloadedIds} onDownload={handleSingleDownload} 
                                        />
                                    )}
                                </main>

                                <Lightbox photo={selectedPhoto} onClose={() => setSelectedPhoto(null)} allPhotos={filteredPhotos} onToggleSelect={toggleSelect} currentIndex={selectedPhotoIndex} onNavigate={handlePhotoChange} downloadedIds={downloadedIds} onDownload={handleSingleDownload} />
                            </div>
                        </>
                    )}
                </div>
            );
        };

        const AlbumRouter = () => {
            const urlParams = new URLSearchParams(window.location.search);
            const albumKey = urlParams.get('album');
            const initialAlbumName = urlParams.get('name');
            if (albumKey) { return <App albumKey={albumKey} initialAlbumName={initialAlbumName} />; } 
            else { return <AlbumEntryPage />; }
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<AlbumRouter />);
    </script>
</body>
</html>
