
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LensFlow - Client Proofing</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            colors: { 
                // PALETTE MỚI: WARM STONE & SOFT GRAY (Hiện đại, dịu mắt)
                gray: { 
                    50: '#fafaf9',  // Warm white (Stone-50) - Nền chính
                    100: '#f5f5f4', // Stone-100 - Nền phụ
                    200: '#e7e5e4', // Stone-200 - Border nhạt
                    300: '#d6d3d1', 
                    400: '#a8a29e', 
                    500: '#78716c', // Text phụ
                    600: '#57534e', 
                    700: '#44403c', 
                    800: '#292524', // Text chính (Soft Black)
                    900: '#1c1917', 
                    950: '#0c0a09' 
                } 
            },
            fontFamily: { sans: ['Inter', 'sans-serif'] }
          }
        }
      }
    </script>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
      body { 
          font-family: 'Inter', sans-serif; 
          /* Sử dụng nền Warm Stone dịu mắt thay vì trắng toát */
          background-color: #fafaf9; 
          color: #292524; 
          margin: 0;
          touch-action: manipulation;
          -webkit-tap-highlight-color: transparent;
      }
      /* Tối ưu scroll cho iOS */
      html, body {
        -webkit-overflow-scrolling: touch;
        overscroll-behavior-y: none;
      }
      ::-webkit-scrollbar { width: 8px; }
      ::-webkit-scrollbar-track { background: #f5f5f4; }
      ::-webkit-scrollbar-thumb { background: #d6d3d1; border-radius: 4px; }
      input[type="password"]::-ms-reveal,
      input[type="password"]::-ms-clear { display: none; }
      
      .gpu-accelerated {
        transform: translateZ(0);
      }
      /* FIX LAG CHO IPHONE */
      .ios-scroll-fix {
        -webkit-overflow-scrolling: touch;
        will-change: transform;
        transform: translateZ(0); /* Kích hoạt card đồ họa GPU */
      }
    </style>
</head>
<body>
    <div id="root"></div>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script>
        // === CẤU HÌNH FIREBASE CỦA BẠN - HÃY THAY THẾ CÁC PLACEHOLDER ===
        const firebaseConfig = {
        apiKey: "AIzaSyD3FNEQkc-BgrgfYddYtAYHurQ63HL2MtE",
        authDomain: "lensflow-proofing-app.firebaseapp.com",
        projectId: "lensflow-proofing-app",
        storageBucket: "lensflow-proofing-app.firebasestorage.app",
        messagingSenderId: "996306881846",
        appId: "1:996306881846:web:f36c35d962ff8e0aa47797",
        databaseURL: "https://lensflow-proofing-app-default-rtdb.asia-southeast1.firebasedatabase.app"
        };
        
        // Khởi tạo Firebase và đối tượng Database
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
    </script>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;

        // === UTILITIES ===
        const getStorage = (key, def) => localStorage.getItem(key) ?? def;
        const getBool = (key, def) => localStorage.getItem(key) === 'true' || (localStorage.getItem(key) === null && def);
        const arrayToObject = (array) => array.reduce((acc, photo) => { acc[photo.id] = photo; return acc; }, {});
        const objectToArray = (object) => object ? Object.values(object) : [];

        // === ICON COMPONENT ===
        // Memoized to prevent unnecessary re-renders
        const Icon = React.memo(({ name, size = 24, className = "", fill = "none", stroke = "currentColor" }) => {
            const icons = {
                heart: <svg width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke={stroke} strokeWidth="2" className={className}><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>,
                check: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><polyline points="20 6 9 17 4 12"></polyline></svg>,
                checkCircle: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>,
                message: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>,
                camera: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>,
                settings: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6m5.2-13.2l-4.2 4.2m0 6l4.2 4.2M23 12h-6m-6 0H1m13.2 5.2l-4.2-4.2m0-6l4.2-4.2"></path></svg>,
                upload: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>,
                cloud: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg>,
                download: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>,
                filter: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>,
                folder: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>,
                lock: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>,
                logOut: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>,
                x: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
                refresh: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>,
                loader: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={`${className} animate-spin`}><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg>,
                grid: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>,
                alert: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>,
                eye: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>,
                messageOn: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path><polyline points="9 10 12 13 16 9"></polyline></svg>,
                messageOff: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path><line x1="9" y1="10" x2="15" y2="10"></line></svg>,
                shield: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>,
                menu: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={stroke} strokeWidth="2" className={className}><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
            };
            return icons[name] || null;
        });
        
        // === PASSCODE/INITIALIZATION MODAL COMPONENT ===
const PasscodeModal = ({ isInitialized, onAccess, onInitialize, error, albumKey }) => {
    const [input, setInput] = useState('');
    // Thêm state nội bộ để quản lý lỗi hiển thị, đồng bộ với prop `error`
    const [internalError, setInternalError] = useState(error);

    useEffect(() => {
        setInternalError(error);
    }, [error]);

    const [adminPassword, setAdminPassword] = useState('');
    const [newPasscode, setNewPasscode] = useState('');

    const handleLogin = (e) => {
        e.preventDefault();
        if (isInitialized) {
            // Chế độ Album đã Khởi tạo (yêu cầu Passcode)
            onAccess(input); 
        } else {
            // Chế độ Khởi tạo Album lần đầu
            onInitialize(adminPassword, newPasscode);
        }
    };

    return (
        <div className="fixed inset-0 z-[100] bg-white/80 backdrop-blur-sm flex items-center justify-center p-4">
            <div className="bg-white border border-gray-200 p-8 rounded-2xl max-w-md w-full shadow-2xl">
                <div className="flex justify-center mb-6 text-pink-500">
                    <Icon name={isInitialized ? "lock" : "shield"} size={48} />
                </div>
                <h2 className="text-2xl font-bold text-center mb-2 text-gray-900">
                    {isInitialized ? 'Truy Cập Album' : 'Khởi Tạo Album'}
                </h2>
                <p className="text-sm text-gray-500 text-center mb-6">
                    {isInitialized ? `Album: ${albumKey}` : 'Vui lòng tạo mật khẩu Admin và Mã truy cập.'}
                </p>

                <form onSubmit={handleLogin}>
                    {/* CHẾ ĐỘ ALBUM ĐÃ KHỞI TẠO (YÊU CẦU PASSCODE) */}
                    {isInitialized && (
                        <>
                            <input type="text" autoFocus value={input} onChange={(e) => {
                                setInput(e.target.value);
                                if (internalError) {
                                    setInternalError(false); // Xóa lỗi khi người dùng bắt đầu nhập lại
                                }
                            }} placeholder="Nhập mã truy cập (Passcode)" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded-lg px-4 py-3 focus:border-pink-500 outline-none mb-4 placeholder-gray-400" />
                            {internalError && <p className="text-red-500 text-xs text-center mb-4">Mã truy cập không hợp lệ.</p>}
                            <button type="submit" className="w-full py-3 rounded-lg bg-pink-500 hover:bg-pink-400 text-white font-bold shadow-lg shadow-pink-500/30 transition-all">
                                Vào Xem Album
                            </button>
                        </>
                    )}

                    {/* CHẾ ĐỘ KHỞI TẠO LẦN ĐẦU (ADMIN ONLY) */}
                    {!isInitialized && (
                        <>
                            <input type="password" value={adminPassword} onChange={(e) => setAdminPassword(e.target.value)} placeholder="Tạo Mật khẩu Admin" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded-lg px-4 py-3 focus:border-pink-500 outline-none mb-3" />
                            <input type="text" value={newPasscode} onChange={(e) => setNewPasscode(e.target.value)} placeholder="Tạo Mã truy cập Khách" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded-lg px-4 py-3 focus:border-pink-500 outline-none mb-4" />
                            {error && <p className="text-red-500 text-xs text-center mb-4">{error}</p>}
                            <button type="submit" disabled={!adminPassword || !newPasscode} className="w-full py-3 rounded-lg bg-green-600 hover:bg-green-500 text-white font-bold disabled:opacity-50 shadow-lg">
                                Khởi Tạo & Truy Cập
                            </button>
                        </>
                    )}
                </form>
            </div>
        </div>
    );
};
        // === PHOTOCARD & LIGHTBOX COMPONENTS ===
        // OPTIMIZED: Removed IntersectionObserver in favor of native lazy loading + onLoad state for performance
        // [SỬA 1]: Thêm onDownload vào danh sách props
        const PhotoCard = React.memo(({ photo, viewMode, onToggleSelect, onUpdateComment, onOpenView, allowComments, onDownload }) => {
            const [isLoaded, setIsLoaded] = useState(false);
            const [localComment, setLocalComment] = useState(photo.comments || "");
            
            useEffect(() => { setLocalComment(photo.comments || ""); }, [photo.comments]);

            const handleCommentBlur = useCallback(() => {
                if (localComment !== photo.comments) onUpdateComment(photo.id, localComment);
            }, [localComment, photo.comments, photo.id, onUpdateComment]);

            const handleCardClick = useCallback(() => { onOpenView(photo); }, [photo, onOpenView]);
            const handleToggleClick = useCallback((e) => { e.stopPropagation(); onToggleSelect(photo.id); }, [photo.id, onToggleSelect]);

            return (
            <div className={`relative group md:rounded-xl overflow-hidden bg-white md:shadow-sm transition-all duration-200 ${photo.isSelected ? 'ring-2 ring-pink-500 shadow-md' : 'md:hover:shadow-lg'}`}>
                <div className="aspect-[3/4] md:aspect-[4/5] cursor-pointer overflow-hidden relative bg-gray-100" onClick={handleCardClick}>
                    <div className={`w-full h-full bg-gray-100 transition-opacity duration-500 ${isLoaded ? 'opacity-0 absolute' : 'opacity-100'}`} />
                    <img src={photo.url} alt="" loading="lazy" decoding="async" onLoad={() => setIsLoaded(true)} className={`w-full h-full object-cover transition-all duration-500 md:group-hover:scale-105 ${isLoaded ? 'opacity-100' : 'opacity-0'}`} style={{ transform: 'translateZ(0)' }} />
                    <div className="absolute inset-0 bg-gradient-to-t from-black/20 via-transparent to-transparent opacity-0 md:group-hover:opacity-100 transition-opacity duration-300" />
                </div>

                <div className="absolute md:translate-y-2 md:group-hover:translate-y-0 bottom-0 left-0 right-0 p-3 transition-transform duration-300 bg-white/95 border-t border-gray-100">
                    {/* [SỬA 2]: Gom nút Tim và nút Download vào 1 hàng */}
                    <div className="flex justify-between items-center mb-2">
                        <span className="text-xs font-medium text-gray-700 truncate flex-1 mr-2">{photo.name}</span>
                        
                        <div className="flex items-center gap-1">
                            {/* Nút Tải Xuống Mới */}
                            <button 
                                onClick={(e) => { e.stopPropagation(); onDownload(photo); }}
                                className="w-8 h-8 flex items-center justify-center rounded-full bg-gray-50 text-gray-400 hover:bg-blue-100 hover:text-blue-600 transition-colors"
                                title="Tải ảnh này"
                            >
                                <Icon name="download" size={16} />
                            </button>

                            {/* Nút Thả Tim Cũ */}
                            <button 
                                onClick={handleToggleClick} 
                                className={`w-8 h-8 flex items-center justify-center rounded-full transition-colors duration-200 ${photo.isSelected ? 'bg-pink-500 text-white shadow-md' : 'bg-gray-100 text-gray-400 hover:bg-gray-200'}`}
                            >
                                {viewMode === 'CLIENT' ? <Icon name="heart" size={16} fill={photo.isSelected ? "currentColor" : "none"} /> : <Icon name="checkCircle" size={16} />}
                            </button>
                        </div>
                    </div>

                    {(photo.isSelected || photo.comments) && (
                        <div className="relative">
                            <div className={`flex items-center gap-2 text-gray-500 mb-1 ${viewMode === 'CLIENT' && !photo.comments && 'hidden'}`}>
                                <Icon name="message" size={12} />
                                <span className="text-[10px] uppercase font-bold tracking-wider text-gray-400">Yêu cầu chỉnh sửa</span>
                            </div>
                            {viewMode === 'CLIENT' ? (
                                allowComments ? (
                                    <textarea value={localComment} onChange={(e) => setLocalComment(e.target.value)} onBlur={handleCommentBlur} placeholder="Ví dụ: Xóa rác, bóp eo..." className="w-full bg-gray-50 text-xs text-gray-800 p-2 rounded-lg border border-gray-200 focus:border-pink-500 focus:bg-white focus:outline-none resize-none h-16 transition-colors" />
                                ) : photo.comments ? <div className="w-full bg-gray-50 text-xs text-gray-600 p-2 rounded border border-gray-200 min-h-[40px] italic opacity-80">{photo.comments}</div> : null
                            ) : (
                                <div className="w-full bg-gray-50 text-xs text-gray-600 p-2 rounded border border-gray-200 min-h-[40px] italic">{photo.comments || "Không có ghi chú."}</div>
                            )}
                        </div>
                    )}
                </div>
                
                {photo.isSelected && <div className="absolute top-2 right-2 bg-pink-500 text-white text-[10px] font-bold px-2 py-1 rounded shadow-md z-10">ĐÃ CHỌN</div>}
            </div>
            );
        }, (prev, next) => prev.photo === next.photo && prev.viewMode === next.viewMode && prev.allowComments === next.allowComments);

        // LIGHTBOX REDESIGN: MODERN LIGHT THEME
// === LIGHTBOX (FINAL: SD/HD TRONG SUỐT + GẦN NÚT CHỌN) ===
        const Lightbox = ({ photo, onClose, allPhotos, onToggleSelect, currentIndex, onNavigate, onDownload }) => {
            if (!photo) return null;
            
            const [scale, setScale] = useState(1);
            const [position, setPosition] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [swipeOffset, setSwipeOffset] = useState(0);
            const [isSwiping, setIsSwiping] = useState(false);
            const [showUI, setShowUI] = useState(true); 

            const touchStartX = React.useRef(0);
            const lastTouchDistance = React.useRef(null);
            
            const [isLoadingHighRes, setIsLoadingHighRes] = useState(false);
            const [isHighResLoaded, setIsHighResLoaded] = useState(false);
            
            const currentPhoto = allPhotos[currentIndex] || photo;
            const prevPhoto = currentIndex > 0 ? allPhotos[currentIndex - 1] : null;
            const nextPhoto = currentIndex < allPhotos.length - 1 ? allPhotos[currentIndex + 1] : null;

            const getDistance = (touches) => {
                return Math.hypot(
                    touches[0].pageX - touches[1].pageX,
                    touches[0].pageY - touches[1].pageY
                );
            };

            useEffect(() => {
                const preloadImage = (src) => {
                    const img = new Image();
                    img.src = src;
                };
                if (nextPhoto) preloadImage(nextPhoto.lightboxUrl || nextPhoto.url);
                if (prevPhoto) preloadImage(prevPhoto.lightboxUrl || prevPhoto.url);
            }, [currentIndex, nextPhoto, prevPhoto]);

            useEffect(() => {
                setIsLoadingHighRes(false);
                setIsHighResLoaded(false);
                setScale(1);
                setPosition({ x: 0, y: 0 });
                setSwipeOffset(0); 
                lastTouchDistance.current = null;
                setShowUI(true); 
            }, [photo.id, photo.lightboxUrl, photo.url]);
            
            const goToPrev = useCallback(() => { if (prevPhoto) { onNavigate(prevPhoto); } }, [prevPhoto, onNavigate]);
            const goToNext = useCallback(() => { if (nextPhoto) { onNavigate(nextPhoto); } }, [nextPhoto, onNavigate]);
            
            const onTouchStart = (e) => {
                if (e.touches.length === 2) {
                    const distance = getDistance(e.touches);
                    lastTouchDistance.current = distance;
                    return;
                }
                if (e.touches.length === 1) {
                    lastTouchDistance.current = null;
                    if (scale > 1) {
                        setIsDragging(true);
                        setDragStart({ 
                            x: e.touches[0].clientX - position.x, 
                            y: e.touches[0].clientY - position.y 
                        });
                    } else {
                        setIsSwiping(true);
                        touchStartX.current = e.targetTouches[0].clientX;
                    }
                }
            }

            const onTouchMove = (e) => {
                if (e.touches.length === 2 && lastTouchDistance.current) {
                    const newDistance = getDistance(e.touches);
                    const delta = newDistance / lastTouchDistance.current;
                    lastTouchDistance.current = newDistance;
                    setScale(prevScale => {
                        const newScale = prevScale * delta;
                        return Math.max(1, Math.min(newScale, 4));
                    });
                    return;
                }
                if (e.touches.length === 1) {
                    if (scale > 1 && isDragging) {
                        setPosition({ 
                            x: e.touches[0].clientX - dragStart.x, 
                            y: e.touches[0].clientY - dragStart.y 
                        });
                    } else if (scale === 1 && isSwiping) {
                        const currentX = e.targetTouches[0].clientX;
                        const diff = currentX - touchStartX.current;
                        setSwipeOffset(diff * 0.2); 
                    }
                }
            }

            const onTouchEnd = () => {
                lastTouchDistance.current = null;
                if (scale > 1) {
                    setIsDragging(false);
                } else {
                    if (!isSwiping) return;
                    setIsSwiping(false);
                    const minSwipeDistance = 15; 
                    if (swipeOffset > minSwipeDistance && prevPhoto) {
                        goToPrev();
                    } else if (swipeOffset < -minSwipeDistance && nextPhoto) {
                        goToNext();
                    } else {
                        setSwipeOffset(0);
                    }
                }
            }

            const handleWheel = (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                setScale(prev => Math.max(1, Math.min(prev * delta, 4)));
            };
            
            const handleMouseDown = (e) => {
                if (scale > 1) {
                    setIsDragging(true);
                    setDragStart({ x: e.clientX - position.x, y: e.clientY - position.y });
                }
            };
            
            const handleMouseMove = (e) => {
                if (isDragging && scale > 1) {
                    setPosition({ x: e.clientX - dragStart.x, y: e.clientY - dragStart.y });
                }
            };
            
            const handleMouseUp = () => setIsDragging(false);
            const resetZoom = () => { setScale(1); setPosition({ x: 0, y: 0 }); };
            const handleLoadHighRes = () => { setIsLoadingHighRes(true); };

            useEffect(() => {
                if (scale > 1.5 && !isHighResLoaded && !isLoadingHighRes) {
                    handleLoadHighRes();
                }
            }, [scale, isHighResLoaded, isLoadingHighRes]);

            const handleDoubleClick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (scale === 1) {
                    setScale(2);
                } else {
                    resetZoom();
                }
            };
            
            useEffect(() => {
                const handleKeyPress = (e) => {
                    if (e.key === 'ArrowLeft') goToPrev();
                    if (e.key === 'ArrowRight') goToNext();
                    if (e.key === 'Escape') onClose();
                };
                window.addEventListener('keydown', handleKeyPress);
                return () => window.removeEventListener('keydown', handleKeyPress);
            }, [goToPrev, goToNext, onClose]);
            
            return (
                <div 
                    className="fixed inset-0 z-50 flex items-center justify-center overflow-hidden" 
                    onClick={onClose}
                    onTouchStart={onTouchStart}
                    onTouchMove={onTouchMove}
                    onTouchEnd={onTouchEnd}
                    style={{ touchAction: 'none' }}
                >
                    <div className="absolute inset-0 z-0 overflow-hidden pointer-events-none">
                        <img 
                            src={currentPhoto.url} 
                            className="w-full h-full object-cover blur-3xl scale-150 opacity-60 transition-all duration-500 ease-linear"
                            alt="" 
                        />
                        <div className="absolute inset-0 bg-white/85 backdrop-blur-sm"></div>
                    </div>

                    {/* --- [SỬA] THÔNG BÁO SD/HD: DỜI XUỐNG GẦN NÚT CHỌN + NỀN TRONG SUỐT --- */}
                    <div className={`absolute bottom-20 md:bottom-24 left-1/2 -translate-x-1/2 z-50 pointer-events-none transition-opacity duration-300 ${showUI ? 'opacity-100' : 'opacity-0'}`}>
                        <span className={`px-3 py-1 rounded-full text-[10px] font-bold shadow-sm border backdrop-blur-md ${
                            isHighResLoaded 
                            ? 'bg-green-100/40 text-green-800 border-green-200/50' // HD: Nền xanh trong suốt
                            : 'bg-white/40 text-gray-600 border-white/50'          // SD: Nền trắng trong suốt
                        }`}>
                            {isHighResLoaded ? 'HD' : 'SD'}
                        </span>
                    </div>
                    
					<button 
						onClick={(e) => { e.stopPropagation(); onDownload(currentPhoto); }} 
						className={`absolute top-4 right-16 md:top-6 md:right-20 text-gray-500 hover:text-blue-600 p-3 bg-white/50 hover:bg-white border border-gray-200 rounded-full transition-all z-50 shadow-sm backdrop-blur-md duration-300 ${showUI ? 'opacity-100' : 'opacity-0 pointer-events-none'} md:opacity-100 md:pointer-events-auto`}
						title="Tải ảnh gốc"
					>
						<Icon name="download" size={24} />
					</button>
                    <button 
                        onClick={onClose} 
                        className={`absolute top-4 right-4 md:top-6 md:right-6 text-gray-500 hover:text-gray-900 p-3 bg-white/50 hover:bg-white border border-gray-200 rounded-full transition-all z-50 shadow-sm backdrop-blur-md duration-300 ${showUI ? 'opacity-100' : 'opacity-0 pointer-events-none'} md:opacity-100 md:pointer-events-auto`}
                    >
                        <Icon name="x" size={24} />
                    </button>

                    <div className={`absolute top-4 left-4 md:top-6 md:left-6 z-50 bg-white/80 border border-gray-100 backdrop-blur px-4 py-2 rounded-full shadow-sm max-w-[calc(100%-6rem)] transition-opacity duration-300 ${showUI ? 'opacity-100' : 'opacity-0'} md:opacity-100`}>
                        <div className="flex items-center gap-3">
                            <span className="text-sm font-bold text-gray-800 truncate">{currentPhoto.name}</span>
                            <span className="text-xs text-gray-400 border-l border-gray-300 pl-3">{currentIndex + 1} / {allPhotos.length} {scale > 1 && `• ${Math.round(scale * 100)}%`}</span>
                        </div>
                    </div>

                    

                    {prevPhoto && (
                        <button 
                            onClick={(e) => { e.stopPropagation(); goToPrev(); }} 
                            className={`hidden md:flex absolute left-6 top-1/2 -translate-y-1/2 text-gray-600 hover:text-gray-900 p-4 bg-white border border-gray-200 shadow-lg hover:shadow-xl rounded-full transition-all z-50`}
                        >
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="15 18 9 12 15 6"></polyline></svg>
                        </button>
                    )}
                    
                    {nextPhoto && (
                        <button 
                            onClick={(e) => { e.stopPropagation(); goToNext(); }} 
                            className={`hidden md:flex absolute right-6 top-1/2 -translate-y-1/2 text-gray-600 hover:text-gray-900 p-4 bg-white border border-gray-200 shadow-lg hover:shadow-xl rounded-full transition-all z-50`}
                        >
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
                        </button>
                    )}

                    <div className="relative w-full h-full flex items-center justify-center" onClick={(e) => { e.stopPropagation(); }}>
                        
                        {prevPhoto && scale === 1 && (
                            <div className="hidden md:block absolute left-[5%] top-1/2 -translate-y-1/2 w-[15vw] h-[50vh] opacity-10 grayscale hover:grayscale-0 hover:opacity-40 scale-95 transition-all duration-500 cursor-pointer" onClick={(e) => { e.stopPropagation(); goToPrev(); }}>
                                <img src={prevPhoto.url} alt="" className="w-full h-full object-cover rounded-lg shadow-lg" />
                            </div>
                        )}

                        <div className="relative z-10 w-full md:w-[70vw] h-full md:h-[90vh] flex items-center justify-center">
                            <div 
                                className="relative w-full h-full flex items-center justify-center"
                                onWheel={handleWheel}
                                onMouseDown={handleMouseDown}
                                onMouseMove={handleMouseMove}
                                onMouseUp={handleMouseUp}
                                onMouseLeave={handleMouseUp}
                                onDoubleClick={handleDoubleClick}
                                style={{ cursor: scale > 1 ? (isDragging ? 'grabbing' : 'grab') : 'default' }}
                            >
                                <img 
                                    src={photo.lightboxUrl || photo.url}
                                    alt=""
                                    className={`absolute max-h-full max-w-full object-contain shadow-2xl ${isHighResLoaded ? 'opacity-0' : 'opacity-100'}`}
                                    style={{ 
                                        transform: scale > 1 
                                            ? `scale(${scale}) translate(${position.x / scale}px, ${position.y / scale}px)`
                                            : `translateX(${swipeOffset}px)`,
                                        transformOrigin: 'center',
                                        transition: (isSwiping || isDragging || lastTouchDistance.current) ? 'none' : 'transform 0.2s ease-out' 
                                    }}
                                    draggable={false}
                                />
                                
                                {(isLoadingHighRes || isHighResLoaded) && (
                                    <img 
                                        src={photo.originalUrl}
                                        alt=""
                                        onLoad={() => { setIsLoadingHighRes(false); setIsHighResLoaded(true); }}
                                        className={`absolute max-h-full max-w-full object-contain shadow-2xl ${isHighResLoaded ? 'opacity-100' : 'opacity-0'}`}
                                        style={{ 
                                            transform: scale > 1 
                                                ? `scale(${scale}) translate(${position.x / scale}px, ${position.y / scale}px)`
                                                : `translateX(${swipeOffset}px)`,
                                            transformOrigin: 'center',
                                            transition: (isSwiping || isDragging || lastTouchDistance.current) ? 'none' : 'transform 0.2s ease-out'
                                        }}
                                        draggable={false}
                                    />
                                )}
                            </div>
                        </div>

                        {nextPhoto && scale === 1 && (
                            <div className="hidden md:block absolute right-[5%] top-1/2 -translate-y-1/2 w-[15vw] h-[50vh] opacity-10 grayscale hover:grayscale-0 hover:opacity-40 scale-95 transition-all duration-500 cursor-pointer" onClick={(e) => { e.stopPropagation(); goToNext(); }}>
                                <img src={nextPhoto.url} alt="" className="w-full h-full object-cover rounded-lg shadow-lg" />
                            </div>
                        )}
                    </div>
					{/* --- [NÚT CHỌN ẢNH SIÊU NHẠY] --- */}
                    <button 
                        // 1. Xử lý cho PC (Chuột)
                        onClick={(e) => { 
                            e.stopPropagation(); 
                            onToggleSelect(currentPhoto.id); 
                        }}

                        // 2. Xử lý cho Mobile (Chạm) -> NHẠY HƠN CLICK RẤT NHIỀU
                        onTouchEnd={(e) => {
                            e.stopPropagation();
                            e.preventDefault(); // Chặn trình duyệt chờ đợi "Click", kích hoạt ngay lập tức
                            onToggleSelect(currentPhoto.id);
                        }}

                        // 3. Chặn sự kiện vuốt lọt vào Lightbox (Fix lỗi đang vuốt mà bấm không ăn)
                        onTouchStart={(e) => e.stopPropagation()}
                        
                        // 4. Tăng vùng bấm ảo (Hit box) lên to hơn mà không làm xấu giao diện
                        // Thêm class: 'before:absolute before:-inset-4 before:content-[""]' để mở rộng vùng bấm ra xung quanh 16px
                        className={`absolute bottom-6 md:bottom-8 left-1/2 -translate-x-1/2 px-6 py-3 md:p-4 rounded-full transition-all z-50 flex items-center gap-2 shadow-xl duration-300 before:absolute before:-inset-6 before:content-[""] ${showUI ? 'translate-y-0 opacity-100' : 'translate-y-10 opacity-0 pointer-events-none'} md:translate-y-0 md:opacity-100 md:pointer-events-auto ${currentPhoto.isSelected ? 'bg-pink-500 text-white ring-4 ring-pink-100' : 'bg-white text-gray-700 border border-gray-200 hover:bg-gray-50'}`}
                    >
                        <Icon name="heart" size={24} fill={currentPhoto.isSelected ? "currentColor" : "none"} />
                        <span className="text-sm font-bold">{currentPhoto.isSelected ? 'ĐÃ CHỌN' : 'CHỌN ẢNH'}</span>
                    </button>
                </div>
            );
        };
//
// === [MỚI] COMPONENT LƯỚI ẢO TỰ VIẾT (Thay thế react-window) ===
        // Giúp web chạy mượt mà không cần tải thư viện ngoài
        const SimpleFixedSizeGrid = React.memo(({ columnCount, columnWidth, height, rowCount, rowHeight, width, children: Cell, itemData, className, style, overscanRowCount = 2 }) => {
            const [scrollTop, setScrollTop] = useState(0);
            const containerRef = React.useRef(null);

            const handleScroll = (e) => {
                setScrollTop(e.target.scrollTop);
            };

            // Tính toán hàng bắt đầu và kết thúc dựa trên vị trí cuộn
            const startIndex = Math.floor(scrollTop / rowHeight);
            const endIndex = Math.min(
                rowCount - 1,
                Math.floor((scrollTop + height) / rowHeight) + overscanRowCount
            );

            const items = [];
            // Render thêm 1 hàng đệm phía trên để tránh bị trắng khi cuộn ngược
            const renderStart = Math.max(0, startIndex - 1); 
            
            for (let rowIndex = renderStart; rowIndex <= endIndex; rowIndex++) {
                for (let columnIndex = 0; columnIndex < columnCount; columnIndex++) {
                    const key = `${rowIndex}-${columnIndex}`;
                    const itemStyle = {
                        position: 'absolute',
                        top: rowIndex * rowHeight,
                        left: columnIndex * columnWidth,
                        height: rowHeight,
                        width: columnWidth,
                    };
                    
                    items.push(
                        <Cell 
                            key={key}
                            columnIndex={columnIndex}
                            rowIndex={rowIndex}
                            style={itemStyle}
                            data={itemData}
                        />
                    );
                }
            }

            return (
                <div 
                    className={className}
                    style={{ ...style, height, width, overflow: 'auto', position: 'relative', WebkitOverflowScrolling: 'touch' }}
                    onScroll={handleScroll}
                >
                    <div style={{ height: rowCount * rowHeight, width: '100%', position: 'relative' }}>
                        {items}
                    </div>
                </div>
            );
        });
// === VIRTUAL GRID COMPONENT (ĐÃ TỐI ƯU CHO IPHONE) ===
        // === VIRTUAL GRID COMPONENT (FIX LỖI HOOK #310) ===
        const VirtualPhotoGrid = React.memo(({ photos, viewMode, onToggleSelect, onUpdateComment, onOpenView, allowComments, onDownload }) => {
            // 1. KHAI BÁO TẤT CẢ HOOK TRƯỚC (KHÔNG ĐƯỢC RETURN Ở ĐÂY)
            const containerRef = React.useRef(null);
            const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

            useEffect(() => {
                if (!containerRef.current) return;
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        setDimensions({
                            width: entry.contentRect.width,
                            height: entry.contentRect.height
                        });
                    }
                });
                resizeObserver.observe(containerRef.current);
                return () => resizeObserver.disconnect();
            }, []);

            // Tính toán các biến số (Vẫn tính toán dù width = 0 để Hook bên dưới có dữ liệu)
            const isMobile = dimensions.width < 768;
            const columnCount = isMobile ? 1 : 5; 
            // Nếu width = 0 thì itemWidth = 0, không sao cả
            const itemWidth = Math.floor(dimensions.width / columnCount);
            const imageRatio = 5 / 4; 
            const footerHeight = 60; 
            const itemHeight = (itemWidth * imageRatio) + footerHeight; 
            const rowCount = Math.ceil(photos.length / columnCount);

            // 2. GỌI CÁC HOOK USEMEMO/USECALLBACK (BẮT BUỘC PHẢI GỌI TRƯỚC KHI RETURN)
            const itemData = useMemo(() => ({
                photos, 
                columnCount, 
                viewMode, 
                onToggleSelect, 
                onUpdateComment, 
                onOpenView, 
                allowComments, 
                itemWidth,
                onDownload: onDownload // <--- ĐÃ SỬA: Dùng prop truyền vào
            }), [photos, columnCount, viewMode, onToggleSelect, onUpdateComment, onOpenView, allowComments, itemWidth, onDownload]);

            const Cell = useCallback(({ columnIndex, rowIndex, style, data }) => {
                const idx = rowIndex * data.columnCount + columnIndex;
                if (idx >= data.photos.length) return null;
                
                const photo = data.photos[idx];
                const gap = 8; 
                
                const itemStyle = {
                    ...style,
                    width: style.width - gap,
                    height: style.height - gap,
                    left: style.left + (gap / 2),
                    top: style.top + (gap / 2)
                };

                return (
                    <div style={itemStyle}>
                        <PhotoCard 
                            photo={photo} 
                            viewMode={data.viewMode} 
                            onToggleSelect={data.onToggleSelect} 
                            onUpdateComment={data.onUpdateComment} 
                            onOpenView={data.onOpenView} 
                            allowComments={data.allowComments}
                            onDownload={data.onDownload} // <--- THÊM DÒNG NÀY
                        />
                    </div>
                );
            }, []);

            // 3. BÂY GIỜ MỚI ĐƯỢC PHÉP KIỂM TRA VÀ RETURN SỚM
            // Nếu chưa đo được kích thước, hiển thị div rỗng để ResizeObserver đo
            if (dimensions.width === 0) {
                return <div ref={containerRef} className="w-full h-full" />;
            }

            // 4. RENDER CHÍNH THỨC
            return (
                <div ref={containerRef} className="w-full h-full">
                    <SimpleFixedSizeGrid
                        className="ios-scroll-fix"
                        columnCount={columnCount}
                        columnWidth={itemWidth}
                        height={dimensions.height}
                        rowCount={rowCount}
                        rowHeight={itemHeight}
                        width={dimensions.width}
                        itemData={itemData}
                        overscanRowCount={2}
                    >
                        {Cell}
                    </SimpleFixedSizeGrid>      
                </div>
            );
        });

        // Trang chủ để người dùng chọn tạo hoặc truy cập album
        const AlbumEntryPage = () => {
            const [albumName, setAlbumName] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                if (!albumName.trim()) return;
                const name = albumName.trim();
                const key = name.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
                window.location.search = `?album=${key}&name=${encodeURIComponent(name)}`;
            };

            return (
                <div className="flex items-center justify-center h-screen bg-gray-50">
                    <div className="bg-white border border-gray-200 p-8 rounded-2xl max-w-md w-full shadow-xl">
                        <div className="flex justify-center mb-6 text-pink-500">
                            <Icon name="camera" size={40} />
                        </div>
                        <h1 className="text-2xl font-bold text-center mb-2 text-gray-900">LensFlow Proofing</h1>
                        <p className="text-sm text-gray-500 text-center mb-8">Client Proofing & Selection</p>

                        <form onSubmit={handleSubmit}>
                            <label className="text-sm font-medium text-gray-700 mb-2 block">Tên Album</label>
                            <input type="text" value={albumName} onChange={e => setAlbumName(e.target.value)} autoFocus placeholder="Nhập tên để tạo hoặc truy cập..." className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded-lg px-4 py-3 focus:border-pink-500 outline-none mb-4 placeholder-gray-400" />
                            <button type="submit" disabled={!albumName.trim()} className="w-full py-3 rounded-lg bg-pink-500 hover:bg-pink-400 text-white font-bold disabled:opacity-50 shadow-lg shadow-pink-500/20">Tiếp tục</button>
                        </form>
                    </div>
                </div>
            );
        };

        // === APP COMPONENT (Quản lý một album cụ thể) ===
        const App = ({ albumKey, initialAlbumName }) => {
            const [photos, setPhotos] = useState([]);
            const [viewMode, setViewMode] = useState('CLIENT');
            const [filterMode, setFilterMode] = useState('ALL');
            const [selectedPhoto, setSelectedPhoto] = useState(null);
            
            // Cấu hình Album và Admin
            const [albumName, setAlbumName] = useState(initialAlbumName || "Chưa đặt tên");

            const [allowComments, setAllowComments] = useState(true);
            const [adminPassword, setAdminPassword] = useState(""); 
            const [driveApiKey, setDriveApiKey] = useState("");
            const [driveFolders, setDriveFolders] = useState([]);
            const [currentFolderId, setCurrentFolderId] = useState('');
            
            const [lastSaveTime, setLastSaveTime] = useState(null); 
            
            const [isAuthenticated, setIsAuthenticated] = useState(false);
            const [showLoginModal, setShowLoginModal] = useState(false);
            const [passwordInput, setPasswordInput] = useState("");
            const [loginError, setLoginError] = useState(false);
            const [notification, setNotification] = useState(null);
            const [isSyncingDrive, setIsSyncingDrive] = useState(false);
            const [syncProgress, setSyncProgress] = useState({ current: 0, total: 0, folderName: '' });
            const [isMovingFiles, setIsMovingFiles] = useState(false);
            const [moveProgress, setMoveProgress] = useState({ current: 0, total: 0, fileName: '' });
			const [showDownloadMenu, setShowDownloadMenu] = useState(false);
			const cancelDownloadRef = React.useRef(false);
//
		async function handleSmartDownload(files) { 
    if (!files || files.length === 0) {
        alert("Không có ảnh để tải!");
        return;
    }

    const ua = navigator.userAgent;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|Opera Mini|Mobile/i.test(ua);
    const isiOS = /iPhone|iPad|iPod/i.test(ua);

    // ================================================================================
    // A. PC MODE — Direct save + Fallback
    // ================================================================================
    if (!isMobile && 'showDirectoryPicker' in window) {

        if (!confirm(`💻 PC MODE:\nTải ${files.length} ảnh.\nSẽ thử lưu trực tiếp, lỗi sẽ chuyển sang mở tab tải.`))
            return;

        let successDirect = 0;
        let fallback = 0;

        try {
            const root = await window.showDirectoryPicker();
            const folderName = `Album_${new Date().toLocaleString('vi-VN').replace(/[\/ :]/g, '_')}`;
            const folder = await root.getDirectoryHandle(folderName, { create: true });

            for (const f of files) {
                try {
                    const res = await fetch(f.url, { mode: "cors" });
                    if (!res.ok) throw new Error("CORS");

                    const blob = await res.blob();
                    const safeName = f.name.replace(/[:\/\\?*|"><]/g, "_");
                    const h = await folder.getFileHandle(safeName, { create: true });
                    const w = await h.createWritable();

                    await w.write(blob);
                    await w.close();
                    successDirect++;

                } catch {
                    fallback++;
                    const tab = window.open(f.url, "_blank");
                    if (tab) setTimeout(() => tab.close(), 3000);
                }

                await wait(400); // giảm lag
            }

            alert(`✔ PC hoàn tất!\n- Ghi trực tiếp: ${successDirect}\n- Tải bằng tab: ${fallback}`);
        } 
        catch (err) {
            alert("Lỗi PC: " + err.message);
        }
        return;
    }

    // ================================================================================
    // B. MOBILE MODE — Sequential Iframe
    // ================================================================================

    const total = files.length;
    const est = Math.ceil(total * 4 / 60);

    if (!confirm(
        `📱 MOBILE MODE:\n` +
        `📸 ${total} ảnh\n` +
        `⏳ Ước tính ~${est} phút\n` +
        `⚠ Nhớ giữ màn hình sáng và KHÔNG thoát trình duyệt.`
    )) return;

    // WakeLock
    let wake = null;
    try {
        if ('wakeLock' in navigator) wake = await navigator.wakeLock.request("screen");
    } catch {}

    let index = 0;

    for (const f of files) {
        index++;
        console.log(`📥 [${index}/${total}] ${f.name}`);

        const iframe = document.createElement("iframe");
        iframe.style.display = "none";

        // Thêm timestamp chống cache
        const sep = f.url.includes("?") ? "&" : "?";
        iframe.src = f.url + `${sep}t=${Date.now()}`;

        document.body.appendChild(iframe);

        // Blind Delay:
        let delay = isiOS ? 4500 : 3500;   // iOS cần delay lớn hơn
        delay += 200 * (f.sizeMB || 5);    // +200ms mỗi MB

        delay = Math.min(delay, 9000);     // tối đa 9s

        await wait(delay);

        // Cleanup memory
        iframe.src = "about:blank";
        try { document.body.removeChild(iframe); } catch {}

        await wait(250);
    }

    if (wake) try { await wake.release(); } catch {}

    alert(`🎉 Đã gửi lệnh tải cho ${total} ảnh!\nKiểm tra thanh thông báo của điện thoại.`);
}

function wait(ms) {
    return new Promise(r => setTimeout(r, ms));
}



			// --- [MỚI] HÀM TẢI 1 ẢNH LẺ ---
            const handleSingleDownload = useCallback(async (photo) => {
                if (!photo) return;
                
                // Chặn click lan truyền nếu bấm từ lưới
                try {
                    showToast(`Đang chuẩn bị tải: ${photo.name}...`, 'info');
                    
                    let blob;
                    // 1. Ưu tiên file gốc local
                    if (photo.originalFile) {
                        blob = photo.originalFile;
                    } 
                    // 2. Tải từ URL (Drive hoặc Link)
                    else {
                        let targetUrl = photo.originalUrl || photo.url;
                        // Thêm API Key nếu là link Drive trực tiếp
                        if (photo.isFromDrive && photo.originalUrl && !photo.originalUrl.includes('key=')) {
                            targetUrl += `&key=${driveApiKey}`;
                        }
                        
                        const response = await fetch(targetUrl);
                        if (!response.ok) throw new Error("Lỗi tải file");
                        blob = await response.blob();
                    }

                    // Dùng thư viện FileSaver (saveAs) đã có sẵn trong code của bạn
                    saveAs(blob, photo.name);
                    showToast(`✅ Đã tải: ${photo.name}`, 'success');

                } catch (error) {
                    console.error(error);
                    showToast("❌ Lỗi khi tải ảnh", "error");
                }
            }, [driveApiKey]);

            const [isInitialized, setIsInitialized] = useState(false); 
            const [showPasscodeModal, setShowPasscodeModal] = useState(true); 
            const [passcodeError, setPasscodeError] = useState(false);
            const [isPasscodeVerified, setIsPasscodeVerified] = useState(false); 
            // Thêm vào App component
            const [isLoading, setIsLoading] = useState(true); // Trạng thái mới: Mặc định là đang tải dữ liệu Firebase config
            const [showAdminPanel, setShowAdminPanel] = useState(false); // State cho Admin Panel trên mobile
            
            const showToast = useCallback((message, type = 'success') => {
                setNotification({ message, type });
                setTimeout(() => setNotification(null), 3000);
            }, []);

            const logActivity = (type, details, metadata = {}) => {
                console.log(`[${viewMode}] ${type}:`, details, metadata);
            };

// --- FIREBASE: LISTENER CHÍNH (Đã sửa lỗi không hiển thị Passcode) ---
useEffect(() => {
    if (!albumKey) return;

    const photosRef = db.ref(`albums/${albumKey}/current_status/photos`);
    const configRef = db.ref(`albums/${albumKey}/config`);
    const savedPasscode = sessionStorage.getItem(`lensflow_passcode_${albumKey}`);
    const adminToken = localStorage.getItem(`lensflow_admin_token_${albumKey}`);

    let photosListener = null;

    // Hàm xử lý khi đã có quyền truy cập (passcode đúng)
    const setupAuthenticatedSession = (configData) => {
        setShowPasscodeModal(false);
        setIsPasscodeVerified(true);

        // Cập nhật cấu hình từ Firebase
        setAlbumName(configData.albumName || 'Chưa đặt tên');
        setDriveFolders(configData.driveFolders || []);
        setDriveApiKey(configData.driveApiKey || '');
        setAdminPassword(configData.adminPassword || '');
        setAllowComments(configData.allowComments !== undefined ? configData.allowComments : true);

        // Chỉ thiết lập listener nếu đã xác thực thành công
        if (isPasscodeVerified && !photosListener) {
            photosListener = photosRef.on('value', (snapshot) => {
                if (!snapshot.exists()) return;
                const photosObject = snapshot.val();
                let photosArray = objectToArray(photosObject);
                // Sắp xếp ảnh theo tên, xử lý số trong tên file một cách tự nhiên
                photosArray.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                setPhotos(photosArray);
                setLastSaveTime(new Date());
            }, (error) => {
                console.error("Firebase Photos Read Error:", error);
                showToast("❌ Lỗi tải dữ liệu ảnh từ Cloud!", 'error');
            });
        }
    };

    // 1. KIỂM TRA TRẠNG THÁI KHỞI TẠO TỪ FIREBASE
    configRef.once('value').then((snapshot) => {
        const configData = snapshot.val();

        if (configData && configData.passcode) {
            // ALBUM ĐÃ KHỞI TẠO
            setIsInitialized(true);

            // LOGIC XÁC THỰC KHI TẢI LẠI TRANG
            // Ưu tiên 1: Kiểm tra xem có phải Admin đang quay lại không?
            if (adminToken && adminToken === configData.adminPassword) {
                 // -> Đúng, là Admin. Vào thẳng giao diện Admin và tải dữ liệu.
                 setIsAuthenticated(true);
                 setViewMode('PHOTOGRAPHER');
                 setupAuthenticatedSession(configData);
                 showToast("Chào mừng Admin trở lại!", 'success');
            } 
            // Ưu tiên 2: Nếu không phải Admin, kiểm tra xem có phải Khách hàng đã đăng nhập không?
            else if (savedPasscode && savedPasscode === configData.passcode) {
                 // -> Đúng, là Khách hàng. Vào giao diện Khách hàng và tải dữ liệu.
                 setupAuthenticatedSession(configData);
            } else {
                 // -> Không phải cả hai. Yêu cầu nhập passcode.
                 setShowPasscodeModal(true);
                 setIsPasscodeVerified(false);
                 localStorage.removeItem(`lensflow_admin_token_${albumKey}`); // Xóa token admin cũ không hợp lệ (nếu có)
            }
        } else {
            // LẦN ĐẦU TRUY CẬP: Chuyển sang chế độ Khởi tạo
            setIsInitialized(false); 
            setShowPasscodeModal(true);

            // ĐẶT TRẠNG THÁI ADMIN NGAY LẬP TỨC CHO VIỆC KHỞI TẠO
            setIsAuthenticated(true);
            setViewMode('PHOTOGRAPHER');
        }

        // --- TẮT LOADING SAU KHI XỬ LÝ XONG ---
        setIsLoading(false);

    }).catch(error => {
        console.error("Firebase Config Read Error:", error);
        setIsLoading(false);
    });
    
    // DỌN DẸP
    return () => {
        if (photosListener) {
            photosRef.off('value', photosListener);
        }
    }; // Thêm isPasscodeVerified vào dependency array để kích hoạt listener
}, [albumKey, isPasscodeVerified]);

            // Cập nhật document title khi albumName thay đổi
            useEffect(() => {
                document.title = `${albumName} - LensFlow`;
            }, [albumName]);

            // Cập nhật cấu hình lên Firebase khi Admin thay đổi (Chỉ Admin Cấu hình)
			const saveConfigToFirebase = useCallback(() => {
				if (!albumKey || viewMode !== 'PHOTOGRAPHER' || !adminPassword) return; 

				// Lấy passcode hiện tại để đảm bảo không bị ghi đè
				db.ref(`albums/${albumKey}/config/passcode`).once('value')
					.then(snapshot => {
						const currentPasscode = snapshot.val(); 
						
						const configData = {
							driveFolders,
							driveApiKey,
							adminPassword,
							allowComments,
							albumName,
							passcode: currentPasscode // SỬ DỤNG PASSCODE HIỆN TẠI
						};

						db.ref(`albums/${albumKey}/config`).set(configData)
							.then(() => console.log('✅ Config saved to Firebase'))
							.catch(err => console.error('❌ Failed to save config:', err));
					})
					.catch(err => console.error('❌ Failed to read passcode for autosave:', err));

			}, [albumKey, driveFolders, driveApiKey, adminPassword, allowComments, albumName, viewMode]);

            // Auto-save config lên Firebase mỗi khi Admin thay đổi
            useEffect(() => {
                const timer = setTimeout(() => saveConfigToFirebase(), 1000); 
                return () => clearTimeout(timer);
            }, [driveFolders, driveApiKey, adminPassword, allowComments, saveConfigToFirebase]);


            // --- CÁC HÀM CẬP NHẬT TRẠNG THÁI (Ghi tối ưu) ---
            // FIX: Wrapped in useCallback and used functional updates to maintain stability and performance
            const toggleSelect = useCallback((id) => {
                setPhotos(prevPhotos => {
                    const index = prevPhotos.findIndex(p => p.id === id);
                    if (index === -1) return prevPhotos;
                    
                    const p = prevPhotos[index];
                    const newState = !p.isSelected;
                    
                    // Fire and forget sync
                    db.ref(`albums/${albumKey}/current_status/photos/${id}`)
                        .update({ isSelected: newState })
                        .catch(console.error);
                    
                    const newPhotos = [...prevPhotos];
                    newPhotos[index] = { ...p, isSelected: newState };
                    return newPhotos;
                });
            }, [albumKey]);

            // FIX: Wrapped in useCallback and used functional updates
            const updateComment = useCallback((id, comment) => {
                // Fire and forget sync (Local state is already handled by PhotoCard via onBlur/onChange)
                // Here we update the main list source of truth
                setPhotos(prevPhotos => {
                    const index = prevPhotos.findIndex(p => p.id === id);
                    if (index === -1) return prevPhotos;
                    
                    const newPhotos = [...prevPhotos];
                    newPhotos[index] = { ...prevPhotos[index], comments: comment };
                    return newPhotos;
                });

                db.ref(`albums/${albumKey}/current_status/photos/${id}`)
                    .update({ comments: comment })
                    .catch(console.error);
            }, [albumKey]);
            
            const handleFileUpload = async (e) => {
                const files = e.target.files;
                if (files) {
                    showToast("Đang xử lý ảnh thumbnail...", "warning");

                    const resizeImage = (file, maxSize = 500) => new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                let { width, height } = img;
                                if (width > height) {
                                    if (width > maxSize) { height *= maxSize / width; width = maxSize; }
                                } else {
                                    if (height > maxSize) { width *= maxSize / height; height = maxSize; }
                                }
                                canvas.width = width;
                                canvas.height = height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, width, height);
                                canvas.toBlob(resolve, 'image/jpeg', 0.8);
                            };
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    });

                    const photoPromises = Array.from(files).map(async (file) => {
                        const thumbnailBlob = await resizeImage(file);
                        return {
                            id: Math.random().toString(36).substr(2, 9),
                            url: URL.createObjectURL(thumbnailBlob), // URL thumbnail đã giảm dung lượng
                            originalUrl: URL.createObjectURL(file), // URL ảnh gốc
                            name: file.name,
                            isSelected: false,
                            comments: '',
                            isFromDrive: false,
                            originalFile: file 
                        };
                    });

                    const newPhotos = await Promise.all(photoPromises);
                    
                    const photosObject = arrayToObject(newPhotos);
                    db.ref(`albums/${albumKey}/current_status/photos`).set(photosObject)
                       .then(() => {
                           showToast(`✅ Đã thêm ${newPhotos.length} ảnh và đồng bộ!`);
                           setPhotos(newPhotos); 
                       })
                       .catch(error => showToast(`Lỗi tải lên Firebase: ${error.message}`, 'error'));
                }
            };

            // --- LOGIC SYNC DRIVE (Đẩy cả Photos và Config lên Firebase) ---
			const syncDataToFirebase = (newPhotosArray, currentFolders, currentApiKey) => {
				
				// Lấy Passcode hiện tại (để bảo tồn nó)
				return db.ref(`albums/${albumKey}/config/passcode`).once('value')
					.then(snapshot => {
						const currentPasscode = snapshot.val();
						
						// 1. Dữ liệu Cấu hình
						const configData = {
							driveFolders: currentFolders,
							driveApiKey: currentApiKey,
							adminPassword: adminPassword,
							allowComments: allowComments,
							albumName,
							passcode: currentPasscode // SỬ DỤNG PASSCODE ĐÃ LẤY ĐƯỢC
						};
				
						// 2. Multi-path update
						const photosObject = arrayToObject(newPhotosArray);
						
						const updates = {};
						updates[`albums/${albumKey}/current_status/photos`] = photosObject;
						updates[`albums/${albumKey}/config`] = configData;

						// Thực hiện update
						return db.ref().update(updates);
					});
				// Lưu ý: Hàm gọi (syncAllFolders) phải xử lý .catch() sau khi gọi hàm này
			};

            const syncAllFolders = async () => {
                if (!driveApiKey) { showToast("Thiếu API Key", "error"); return; }
                const validFolders = driveFolders.filter(f => f.id && f.id.trim());
                if (validFolders.length === 0) { showToast("Chưa có Folder ID hợp lệ", "error"); return; }

                const existingSelections = photos.filter(p => p.isSelected || p.comments);
                if (existingSelections.length > 0) {
                    const confirm = window.confirm(
                        `Bạn đã có ${existingSelections.length} ảnh đã chọn/comment.\n\n` +
                        `CHỌ "OK" để GIỮ lựa chọn cũ và sync tất cả.\n` +
                        `CHỌ "Cancel" để hủy bỏ.`
                    );
                    if (!confirm) return;
                }

                setIsSyncingDrive(true);
                setSyncProgress({ current: 0, total: validFolders.length, folderName: '' });
                
                try {
                    let allPhotosFromAllFolders = [];
                    const existingMap = new Map(photos.map(p => [p.id, p]));

                    for (let i = 0; i < validFolders.length; i++) {
                        const folder = validFolders[i];
                        setSyncProgress({ current: i + 1, total: validFolders.length, folderName: folder.name || `Folder ${i + 1}` });
                        
                        let folderFiles = [];
                        let pageToken = null;
                        
                        do {
                            let url = `https://www.googleapis.com/drive/v3/files?q='${folder.id}'+in+parents+and+mimeType+contains+'image/'&fields=nextPageToken,files(id,name,thumbnailLink,webContentLink)&key=${driveApiKey}&pageSize=100`;
                            if (pageToken) url += `&pageToken=${pageToken}`;
                            
                            const res = await fetch(url);
                            const data = await res.json();
                            
                            if (data.error) throw new Error(`${folder.name}: ${data.error.message}`);
                            
                            if (data.files && data.files.length > 0) {
                                const taggedFiles = data.files.map(file => ({...file, folderName: folder.name}));
                                folderFiles = [...folderFiles, ...taggedFiles];
                            }
                            
                            pageToken = data.nextPageToken;
                        } while (pageToken);
                        
                        allPhotosFromAllFolders = [...allPhotosFromAllFolders, ...folderFiles];
                        showToast(`✅ ${folder.name}: ${folderFiles.length} ảnh`, 'success');
                    }

                    if (allPhotosFromAllFolders.length > 0) {
                        let newPhotos = allPhotosFromAllFolders.map(f => {
                            const existing = existingMap.get(f.id);
                            return {
                                id: f.id,
                                // Sửa w500 -> w300 để nhẹ hơn
                                url: `https://drive.google.com/thumbnail?id=${f.id}&sz=w300`,
                                // Sửa w2000 -> w1600 (vẫn nét nhưng đỡ tốn RAM hơn)
                                lightboxUrl: `https://drive.google.com/thumbnail?id=${f.id}&sz=w1600`,
                                originalUrl: `https://www.googleapis.com/drive/v3/files/${f.id}?alt=media&key=${driveApiKey}`,
                                name: f.name,
                                folderName: f.folderName, 
                                isSelected: existing?.isSelected || false,
                                comments: existing?.comments || '',
                                isFromDrive: true
                            };
                        });

                        // Sắp xếp danh sách ảnh tổng hợp trước khi gửi lên Firebase
                        newPhotos.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                        
                        await syncDataToFirebase(newPhotos, validFolders, driveApiKey);

                        showToast(`✅ Tổng cộng: ${allPhotosFromAllFolders.length} ảnh từ ${validFolders.length} thư mục đã đồng bộ!`);
                        logActivity('SYNC_ALL_FOLDERS', `${allPhotosFromAllFolders.length} ảnh từ ${validFolders.length} folders`);
                    } else {
                        showToast("Không có ảnh", "warning");
                    }
                } catch (error) {
                    showToast("Lỗi: " + error.message, "error");
                } finally {
                    setIsSyncingDrive(false);
                    setSyncProgress({ current: 0, total: 0, folderName: '' });
                }
            };
            
            // --- HÀM BACKUP/RESTORE CHUYỂN SANG SNAPSHOT ---
            
            const handleSaveSnapshot = () => {
                const timestampKey = new Date().toISOString().replace(/\./g, '-');
                
                const photosObject = photos.reduce((acc, p) => { acc[p.id] = p; return acc; }, {});
                
                const snapshotData = { 
                    photos: photosObject, 
                    config: { driveFolders, allowComments, adminPassword, driveApiKey, albumName }, 
                    metadata: { 
                        timestamp: new Date().toLocaleString('vi-VN'),
                        selectedCount: photos.filter(p => p.isSelected).length 
                    }
                };

                db.ref(`albums/${albumKey}/history/${timestampKey}`).set(snapshotData)
                    .then(() => showToast(`✅ Đã lưu Snapshot phiên bản: ${new Date().toLocaleTimeString('vi-VN')}`, 'success'))
                    .catch(error => showToast(`Lỗi lưu lịch sử: ${error.message}`, 'error'));
            };
            
            // --- CÁC HÀM KHÁC GIỮ NGUYÊN ---
            const handleDownloadReport = () => {
    // 1. Lọc các ảnh đã được chọn (isSelected: true)
    const selected = photos.filter(p => p.isSelected);
    
    if (!selected.length) { 
        showToast("Chưa chọn ảnh", "warning"); 
        return; 
    }
    
    let content = `BÁO CÁO - ${albumName.toUpperCase()}\nNgày: ${new Date().toLocaleString('vi-VN')}\nSố lượng: ${selected.length}\n${'='.repeat(50)}\n\n`;
    
    // Ghi log để kiểm tra
    console.log(`Báo cáo đang xử lý ${selected.length} ảnh đã chọn...`);
    
    // 2. Nhóm ảnh theo folder (folderName)
    const groupedByFolder = {};
    selected.forEach(p => {
        // Sử dụng folderName hoặc giá trị mặc định nếu thiếu
        const folderName = p.folderName || 'Không rõ thư mục'; 
        if (!groupedByFolder[folderName]) {
            groupedByFolder[folderName] = [];
        }
        groupedByFolder[folderName].push(p);
    });
    
    // 3. Xây dựng nội dung file (.txt)
    Object.keys(groupedByFolder).forEach(folderName => {
        content += `\n\n┌${'\u2500'.repeat(48)}\u2510\n`;
        content += `│  ${folderName.toUpperCase().padEnd(46)}│\n`;
        content += `└${'\u2500'.repeat(48)}\u2518\n\n`;
        
        groupedByFolder[folderName].forEach((p, i) => {
            // Chuẩn hóa ghi chú: loại bỏ khoảng trắng và thay thế bằng '(Không có ghi chú)' nếu rỗng
            const commentText = p.comments && p.comments.trim() ? p.comments : "(Không có ghi chú)";
            
            content += `${i + 1}. ${p.name}\n   ${commentText}\n${'='.repeat(50)}\n`;
        });
    });

    // Ghi log nội dung file đã hoàn thành
    console.log('Nội dung báo cáo đã tạo:', content); 
    
    // 4. Tạo Blob và Download File (Tăng độ tin cậy)
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    const link = document.createElement('a');
    
    // Tạo tên file an toàn
    const filename = `Order_${albumName.replace(/\s+/g, '_')}.txt`;
    link.download = filename; 
    
    link.href = URL.createObjectURL(blob);
    
    // Thao tác download: Chèn vào DOM, click, và gỡ bỏ để tránh bị chặn pop-up
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Thu hồi URL object để giải phóng bộ nhớ
    URL.revokeObjectURL(link.href);

    showToast("Đã xuất file!", 'success');
};
            const handleMoveToFinal = async () => {
    const selected = photos.filter(p => p.isSelected);
    if (!selected.length) { 
        showToast("Chưa có ảnh nào được chọn", "warning"); 
        return; 
    }

    setIsMovingFiles(true);
    setMoveProgress({ current: 0, total: selected.length, fileName: '' });
    
    // Kiểm tra hỗ trợ File System Access API (Lưu trực tiếp vào folder)
    if ('showDirectoryPicker' in window) {
        try {
            // Cho phép user chọn folder đích
            const dirHandle = await window.showDirectoryPicker();
            let successCount = 0;
            let failCount = 0;

            // Lưu từng file vào folder đã chọn
            for (let i = 0; i < selected.length; i++) {
                const photo = selected[i];
                setMoveProgress({ current: i + 1, total: selected.length, fileName: photo.name });
                
                try {
                    let blob;
                    
                    if (photo.originalFile) {
                        // Nếu là file local (khi upload bằng input), dùng file gốc
                        blob = photo.originalFile;
                    } 
                    else if (photo.isFromDrive && photo.originalUrl) {
                        // Nếu từ Drive, tải file gốc (dùng originalUrl với API Key)
                        const response = await fetch(photo.originalUrl);
                        if (!response.ok) throw new Error(`Không thể tải file gốc từ Drive (Status: ${response.status})`);
                        blob = await response.blob();
                    }
                    else {
                        // Fallback: dùng URL hiện tại (có thể là thumbnail nếu originalUrl lỗi)
                        const response = await fetch(photo.url);
                        if (!response.ok) throw new Error("Không thể tải ảnh (Fallback URL)");
                        blob = await response.blob();
                    }
                    
                    const fileHandle = await dirHandle.getFileHandle(photo.name, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    successCount++;
                } catch (err) {
                    console.error(`Lỗi lưu ${photo.name}:`, err);
                    failCount++;
                }
            }

            setMoveProgress({ current: 0, total: 0, fileName: '' });
            
            if (successCount > 0) {
                showToast(`✅ Đã lưu ${successCount}/${selected.length} ảnh gốc vào folder!${failCount > 0 ? ` (Lỗi: ${failCount})` : ''}`, 'success');
            } else {
                showToast("❌ Không thể lưu ảnh nào. Vui lòng kiểm tra console.", "error");
            }
        } catch (err) {
            if (err.name !== 'AbortError') {
                console.error(err);
                showToast("Lỗi khi chọn folder: " + err.message, "error");
            }
            setMoveProgress({ current: 0, total: 0, fileName: '' });
        }
    } else {
        // Fallback: Tải xuống từng file nếu trình duyệt không hỗ trợ File System Access API
        showToast("Trình duyệt không hỗ trợ chọn folder. Đang tải xuống từng file...", "warning");
        
        for (let i = 0; i < selected.length; i++) {
            const photo = selected[i];
            setMoveProgress({ current: i + 1, total: selected.length, fileName: photo.name });
            
            // Dùng Original URL (hoặc URL thumbnail nếu không có) để tải về
            const downloadUrl = photo.originalUrl || photo.url; 
            
            // Chờ một chút giữa các lần tải để tránh bị trình duyệt chặn
            await new Promise(resolve => setTimeout(resolve, 300));
            
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = photo.name;
            
            // Thực hiện download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        setMoveProgress({ current: 0, total: 0, fileName: '' });
        showToast(`Đã tải ${selected.length} ảnh xuống thư mục Downloads!`, 'success');
    }
    
    setIsMovingFiles(false);
};
// Hàm Khởi tạo Album lần đầu
const handleInitializeAlbum = (adminPasswordInput, newPasscodeInput) => {
    // 1. Kiểm tra dữ liệu đầu vào cơ bản
    if (adminPasswordInput.length < 4 || newPasscodeInput.length < 4) {
        setPasscodeError("Mật khẩu Admin và Passcode Khách hàng phải có ít nhất 4 ký tự.");
        return;
    }

        // Lưu token Admin vào localStorage để tự động đăng nhập lại
        localStorage.setItem(`lensflow_admin_token_${albumKey}`, adminPasswordInput);
    
    // 2. Dữ liệu cấu hình lần đầu (ĐẢM BẢO PASSCODE CÓ MẶT)
    const configData = {
        driveFolders: [],
        driveApiKey: '',
        adminPassword: adminPasswordInput,
        allowComments: true,
        passcode: newPasscodeInput, // <-- PASSCODE ĐƯỢC THIẾT LẬP Ở ĐÂY
        albumName // Sử dụng albumName từ state, được truyền từ URL
    };
    
    // 3. Chuẩn bị Multi-path update
    const updates = {};
    updates[`albums/${albumKey}/config`] = configData;
    updates[`albums/${albumKey}/current_status/photos`] = {}; 
    
    // 4. Ghi dữ liệu lên Firebase
    db.ref().update(updates)
        .then(() => {
            // --- THÀNH CÔNG GHI FIREBASE ---

            // Lưu Passcode vào Session để Admin truy cập lại không cần nhập
            sessionStorage.setItem(`lensflow_passcode_${albumKey}`, newPasscodeInput);
            
            // Cập nhật state Admin và truy cập
            setAdminPassword(adminPasswordInput);
            setIsInitialized(true); // Đánh dấu đã khởi tạo
            setIsPasscodeVerified(true); // Đã xác thực Passcode
            setShowPasscodeModal(false);
            setIsAuthenticated(true);
            setViewMode('PHOTOGRAPHER'); // Chuyển sang chế độ Admin
            
            // 5. Thiết lập Listener Photos ngay sau khi khởi tạo thành công
            const photosRef = db.ref(`albums/${albumKey}/current_status/photos`);
            photosRef.on('value', (snapshot) => {
                if (!snapshot.exists()) return; 
                const photosObject = snapshot.val();
                const photosArray = objectToArray(photosObject); 
                setPhotos(photosArray);
                setLastSaveTime(new Date()); 
            });

            showToast("✅ Khởi tạo thành công! Bạn đang ở chế độ Admin.", 'success');
        })
        .catch(err => {
            // Xử lý lỗi Firebase
            console.error("Lỗi Firebase khi khởi tạo:", err);
            setPasscodeError("Lỗi Firebase khi khởi tạo. Vui lòng kiểm tra Console (F12).");
        });
};



// Hàm xác thực Passcode (cho Khách hàng và Admin khi album đã có)
const handlePasscodeAccess = async (inputPasscode) => {
    setPasscodeError(false);
    
    // Sửa lỗi: Thay vì chỉ lấy passcode, chúng ta lấy toàn bộ config
    try {
        const snapshot = await db.ref(`albums/${albumKey}/config`).once('value');
        const configData = snapshot.val();
        
        if (configData && inputPasscode === configData.passcode) {
            // --- THÀNH CÔNG ---
            sessionStorage.setItem(`lensflow_passcode_${albumKey}`, inputPasscode);

            // Cập nhật state để kích hoạt useEffect tải ảnh
            setAlbumName(configData.albumName || 'Chưa đặt tên');
            setDriveFolders(configData.driveFolders || []);
            setDriveApiKey(configData.driveApiKey || '');
            setAdminPassword(configData.adminPassword || '');
            setAllowComments(configData.allowComments !== undefined ? configData.allowComments : true);

            setShowPasscodeModal(false);
            setIsPasscodeVerified(true); // <-- Dòng này sẽ kích hoạt useEffect để tải ảnh

            setViewMode('CLIENT'); // Mặc định là Client
            showToast("✅ Truy cập thành công!");
        } else {
            // --- THẤT BẠI ---
            setPasscodeError(true);
        }
    } catch(e) {
        console.error("Lỗi xác thực Passcode:", e);
        setPasscodeError(true);
    }
};






            const handleLogin = () => {
                // Sửa lỗi: Chỉ so sánh khi adminPassword đã được tải và passwordInput khớp
                if (adminPassword && passwordInput === adminPassword) { 
                    setIsAuthenticated(true);
                    setShowLoginModal(false);
                    setLoginError(false);
                    setPasswordInput("");
                    // Lưu token vào localStorage để tự động đăng nhập lại
                    localStorage.setItem(`lensflow_admin_token_${albumKey}`, passwordInput);

                    setViewMode('PHOTOGRAPHER');
                } else {
                    setLoginError(true);
                }
            };

            const filteredPhotos = useMemo(() => {
                let result = photos;

                // Sửa lỗi: Áp dụng bộ lọc thư mục cho cả Admin và Client
                if (currentFolderId) {
                    const folderName = driveFolders.find(f => f.id === currentFolderId)?.name;
                    result = result.filter(p => p.folderName === folderName);
                }

                if (filterMode === 'SELECTED') {
                    result = result.filter(p => p.isSelected);
                }
                
                return result;
            }, [photos, filterMode, currentFolderId, viewMode, driveFolders]);
            
            const selectedCount = useMemo(() => photos.filter(p => p.isSelected).length, [photos]);

            // Tính toán số liệu cho bộ đếm trong view hiện tại
            const viewStats = useMemo(() => {
                // Lấy danh sách ảnh đã được lọc theo thư mục (chưa lọc theo "SELECTED")
                let baseFiltered = photos;
                if (currentFolderId) {
                    const folderName = driveFolders.find(f => f.id === currentFolderId)?.name;
                    baseFiltered = baseFiltered.filter(p => p.folderName === folderName);
                }
                
                const selectedInView = baseFiltered.filter(p => p.isSelected).length;
                const totalInView = baseFiltered.length;

                return { selected: selectedInView, total: totalInView };
            }, [photos, currentFolderId, driveFolders]);

            const selectedPhotoIndex = useMemo(() => {
                return selectedPhoto ? filteredPhotos.findIndex(p => p.id === selectedPhoto.id) : -1;
            }, [selectedPhoto, filteredPhotos]);
            
            const handlePhotoChange = useCallback((newPhoto) => {
                setSelectedPhoto(newPhoto);
            }, []);

            return (
                <div className="flex h-screen bg-gray-50 text-gray-900">
                    {notification && (
                        <div className={`fixed top-4 left-1/2 -translate-x-1/2 z-[100] px-6 py-3 rounded-full shadow-2xl flex items-center gap-2 border ${
                        notification.type === 'success' ? 'bg-green-50 border-green-500 text-green-700' : 
                        notification.type === 'error' ? 'bg-red-50 border-red-500 text-red-700' : 
                        'bg-yellow-50 border-yellow-500 text-yellow-700'
                        }`}>
                            {notification.type === 'success' ? <Icon name="check" size={18} /> : <Icon name="alert" size={18} />}
                            <span className="text-sm font-medium">{notification.message}</span>
                        </div>
                    )}
                    {isLoading && (
                      <div className="fixed inset-0 z-[110] bg-gray-50 flex items-center justify-center text-pink-500">
                          <Icon name="loader" size={40} />
                          <span className="ml-3 text-lg text-gray-500">Đang tải cấu hình...</span>
                      </div>
                    )}
{showPasscodeModal && !isLoading && (
    <PasscodeModal 
        isInitialized={isInitialized} 
        onAccess={handlePasscodeAccess} 
        onInitialize={handleInitializeAlbum} 
        error={passcodeError} 
        albumKey={albumKey}
    />
)}
 

                    {showLoginModal && (
                        <div className="fixed inset-0 bg-gray-900/50 backdrop-blur-sm z-[60] flex items-center justify-center p-4">
                            <div className="bg-white border border-gray-200 p-8 rounded-2xl max-w-sm w-full shadow-xl">
                                <div className="flex justify-center mb-6 text-pink-500">
                                    <Icon name="lock" size={48} />
                                </div>
                                <h2 className="text-xl font-bold text-center mb-4 text-gray-900">Quản trị viên</h2>
                                <input type="password" autoFocus value={passwordInput} onChange={(e) => setPasswordInput(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && handleLogin()} placeholder="Mật khẩu..." className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded-lg px-4 py-3 focus:border-pink-500 outline-none mb-4" />
                                {loginError && <p className="text-red-500 text-xs text-center mb-4">Sai mật khẩu</p>}
                                <div className="flex gap-3">
                                    <button onClick={() => setShowLoginModal(false)} className="flex-1 py-2 rounded-lg border border-gray-200 text-gray-600 hover:bg-gray-100">Hủy</button>
                                    <button onClick={handleLogin} className="flex-1 py-2 rounded-lg bg-pink-500 hover:bg-pink-400 text-white font-bold shadow-lg shadow-pink-500/20">Đăng nhập</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Progress Modal (Giữ nguyên) */}
{/* Progress Modal (CÓ NÚT HỦY) */}
                    {isMovingFiles && moveProgress.total > 0 && (
                        <div className="fixed inset-0 bg-gray-900/50 backdrop-blur-sm z-[70] flex items-center justify-center p-4">
                            <div className="bg-white border border-gray-200 p-8 rounded-2xl max-w-md w-full shadow-xl">
                                <div className="flex justify-center mb-4 text-green-500">
                                    <Icon name="loader" size={48} />
                                </div>
                                <h2 className="text-lg font-bold text-center mb-6 text-gray-900">
                                    {viewMode === 'PHOTOGRAPHER' ? "Đang lưu ảnh gốc..." : "Đang tải xuống..."}
                                </h2>
                                
                                <div className="mb-4">
                                    <div className="flex justify-between text-sm mb-2">
                                        <span className="text-gray-500">Tiến trình:</span>
                                        <span className="text-green-600 font-bold">{moveProgress.current}/{moveProgress.total}</span>
                                    </div>
                                    <div className="w-full bg-gray-100 rounded-full h-1.5">
                                        <div className="bg-gradient-to-r from-green-500 to-emerald-500 h-full transition-all duration-300" style={{width: `${(moveProgress.current / moveProgress.total) * 100}%`}}></div>
                                    </div>
                                </div>
                                
                                <div className="bg-gray-50 p-3 rounded-lg border border-gray-200 mb-6">
                                    <p className="text-xs text-gray-400 mb-1">Đang xử lý:</p>
                                    <p className="text-sm text-gray-800 truncate font-mono">{moveProgress.fileName}</p>
                                </div>
                                
                                {/* --- [MỚI] NÚT HỦY BỎ --- */}
                                <button 
                                    onClick={() => {
                                        // Bật cờ hủy -> Vòng lặp sẽ dừng ở ảnh tiếp theo
                                        cancelDownloadRef.current = true;
                                    }}
                                    className="w-full py-2.5 rounded-lg border border-red-200 text-red-600 font-bold hover:bg-red-50 transition-colors flex items-center justify-center gap-2"
                                >
                                    <Icon name="x" size={18} />
                                    Hủy bỏ
                                </button>
                            </div>
                        </div>
                    )}
                    
                    {isPasscodeVerified && (
                    <>
                        {/* Lớp phủ mờ cho Admin Panel trên mobile */}
                        {showAdminPanel && viewMode === 'PHOTOGRAPHER' && (
                            <div 
                                className="fixed inset-0 bg-black/20 z-30 md:hidden"
                                onClick={() => setShowAdminPanel(false)}
                            ></div>
                        )}

                        {/* Admin Panel */}
                        <div className={`fixed md:relative top-0 left-0 h-full z-40 md:z-auto transition-transform duration-300 ease-in-out bg-white border-r border-gray-200 overflow-hidden ${
                            viewMode === 'PHOTOGRAPHER' ? 'w-80' : 'w-0'
                        } ${showAdminPanel ? 'translate-x-0' : '-translate-x-full'} md:translate-x-0 shadow-xl md:shadow-none`}>
                            <div className="p-6 overflow-y-auto h-full">
                                <div className="flex items-center justify-between gap-2 text-pink-500 mb-8">
                                    <Icon name="camera" size={28} />
                                    <span className="font-bold text-xl text-gray-900">Admin Panel</span>
                                    <button onClick={() => setShowAdminPanel(false)} className="md:hidden p-2 text-gray-400 hover:text-gray-600"><Icon name="x" size={20} /></button>
                                </div>
                                
                                <div className="mb-6">
                                    <h3 className="text-xs font-bold text-gray-400 uppercase mb-3 flex items-center gap-2">
                                        <Icon name="settings" size={12} /> Cài đặt
                                    </h3>
                                    <input type="text" value={albumName} onChange={(e) => setAlbumName(e.target.value)} placeholder="Tên Album" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded px-3 py-2 text-sm mb-3 focus:border-pink-500 outline-none"/>
                                    
                                    <div className="flex items-center justify-between bg-gray-50 p-3 rounded-lg border border-gray-200">
                                        <div className="flex items-center gap-2 text-sm text-gray-700">
                                            {allowComments ? <Icon name="messageOn" size={16} className="text-green-500" /> : <Icon name="messageOff" size={16} className="text-red-400" />}
                                            <span>Bình luận</span>
                                        </div>
                                        <button onClick={() => setAllowComments(!allowComments)} className={`w-10 h-5 rounded-full relative ${allowComments ? 'bg-green-500' : 'bg-gray-300'}`}>
                                            <div className={`absolute top-1 w-3 h-3 bg-white rounded-full transition-all shadow-sm ${allowComments ? 'left-6' : 'left-1'}`} />
                                        </button>
                                    </div>
                                    <input type="password" value={adminPassword} onChange={(e) => setAdminPassword(e.target.value)} placeholder="Admin Password" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded px-3 py-2 text-sm mt-3 focus:border-pink-500 outline-none"/>
                                </div>

                                <div className="mb-6">
                                    <h3 className="text-xs font-bold text-gray-400 uppercase mb-3 flex items-center gap-2">
                                        <Icon name="cloud" size={12} /> Google Drive Folders
                                    </h3>
                                    <input type="password" value={driveApiKey} onChange={(e) => setDriveApiKey(e.target.value)} placeholder="API Key" className="w-full bg-gray-50 border border-gray-200 text-gray-900 rounded px-3 py-2 text-xs mb-3 focus:border-pink-500 outline-none"/>
                                    
                                    <div className="space-y-2 mb-3 max-h-40 overflow-y-auto">
                                        {driveFolders.map((folder, idx) => (
                                            <div key={idx} className="flex gap-2 items-center bg-gray-50 p-2 rounded border border-gray-200">
                                                <input type="text" value={folder.name} onChange={(e) => {
                                                    const newFolders = [...driveFolders];
                                                    newFolders[idx].name = e.target.value;
                                                    setDriveFolders(newFolders);
                                                }} placeholder="Tên" className="w-20 bg-white border border-gray-200 rounded px-2 py-1 text-xs focus:border-pink-500 outline-none text-gray-800"/>
                                                <input type="text" value={folder.id} onChange={(e) => {
                                                    const newFolders = [...driveFolders];
                                                    newFolders[idx].id = e.target.value;
                                                    setDriveFolders(newFolders);
                                                }} placeholder="Folder ID" className="flex-1 bg-white border border-gray-200 rounded px-2 py-1 text-xs focus:border-pink-500 outline-none text-gray-800"/>
                                                <button onClick={() => setDriveFolders(driveFolders.filter((_, i) => i !== idx))} className="p-1.5 bg-red-50 text-red-500 hover:bg-red-100 rounded">
                                                    <Icon name="x" size={12} />
                                                </button>
                                            </div>
                                        ))}
                                    </div>
                                    
                                    <button onClick={() => setDriveFolders([...driveFolders, {name: '', id: ''}])} className="w-full py-1.5 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded text-xs mb-3 flex items-center justify-center gap-1 transition-colors">
                                        <span className="text-lg leading-none">+</span> Thêm folder
                                    </button>
                                    
                                    {driveFolders.length > 0 && (
                                        <button onClick={syncAllFolders} disabled={isSyncingDrive} className="w-full py-2 bg-pink-50 hover:bg-pink-100 text-pink-600 border border-pink-200 rounded-lg text-xs font-bold flex items-center justify-center gap-2 disabled:opacity-50 mb-3 transition-colors">
                                            {isSyncingDrive ? <><Icon name="loader" size={14} /> Đang sync...</> : <><Icon name="refresh" size={14} /> Sync Tất Cả ({driveFolders.filter(f => f.id).length})</>}
                                        </button>
                                    )}
                                    
                                    {isSyncingDrive && syncProgress.total > 0 && (
                                        <div className="bg-gray-50 p-2 rounded border border-gray-200 mb-3">
                                            <div className="text-[10px] text-gray-500 mb-1">
                                                {syncProgress.folderName} ({syncProgress.current}/{syncProgress.total})
                                            </div>
                                            <div className="w-full bg-gray-200 rounded-full h-1.5">
                                                <div className="bg-pink-500 h-full rounded-full transition-all" style={{width: `${(syncProgress.current / syncProgress.total) * 100}%`}}></div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    {driveFolders.length > 0 && (
                                        <div className="space-y-2">
                                            <label className="text-[10px] text-gray-400 uppercase font-semibold">Xem trước:</label>
                                            <select value={currentFolderId} onChange={(e) => {
                                                const newFolderId = e.target.value;
                                                setCurrentFolderId(newFolderId);
                                            }} className="w-full bg-gray-50 border border-gray-200 text-gray-800 rounded px-2 py-2 text-xs focus:border-pink-500 outline-none">
                                                <option value="">Tất cả thư mục</option>
                                                {driveFolders.map((folder, idx) => (
                                                    <option key={idx} value={folder.id}>{folder.name || `Folder ${idx + 1}`}</option>
                                                ))}
                                            </select>
                                        </div>
                                    )}
                                </div>

                                <div className="mb-6">
                                    <h3 className="text-xs font-bold text-gray-400 uppercase mb-3 flex items-center gap-2">
                                        <Icon name="shield" size={12} /> Cloud Storage (Firebase)
                                    </h3>
                                    <button onClick={handleSaveSnapshot} className="w-full py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg text-xs font-medium flex items-center justify-center gap-1 shadow-md shadow-blue-200">
                                        <Icon name="download" size={14} /> Save Snapshot
                                    </button>
                                    {/* Thêm giao diện để chọn và khôi phục Snapshot ở đây nếu cần */}
                                </div>

                                <div className="mb-6">
                                    <h3 className="text-xs font-bold text-gray-400 uppercase mb-3 flex items-center gap-2">
                                        <Icon name="upload" size={12} /> Upload Local
                                    </h3>
                                    <label className="flex flex-col items-center justify-center w-full h-16 border-2 border-gray-300 border-dashed rounded-xl hover:bg-gray-50 hover:border-pink-300 cursor-pointer group transition-all">
                                        <Icon name="folder" size={24} className="text-gray-400 group-hover:text-pink-500 transition-colors" />
                                        <span className="text-[10px] text-gray-500 mt-1">Chọn ảnh</span>
                                        <input type="file" className="hidden" multiple accept="image/*" onChange={handleFileUpload} />
                                    </label>
                                </div>

                                <div className="space-y-3 border-t border-gray-100 pt-6">
                                    <div className="flex justify-between text-sm">
                                        <span className="text-gray-500">Đã chọn:</span>
                                        <span className="font-bold text-pink-500">{selectedCount} ảnh</span>
                                    </div>
                                    <button onClick={() => setFilterMode(filterMode === 'ALL' ? 'SELECTED' : 'ALL')} className={`w-full py-2 rounded-lg text-xs font-medium flex items-center justify-center gap-2 ${filterMode === 'SELECTED' ? 'bg-pink-500 text-white' : 'bg-gray-100 text-gray-600'}`}>
                                        {filterMode === 'SELECTED' ? <><Icon name="eye" size={14} /> Hiện tất cả</> : <><Icon name="filter" size={14} /> Xem ảnh chọn</>}
                                    </button>
                                    
                                    <button onClick={handleDownloadReport} disabled={!selectedCount} className="w-full py-3 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white rounded-lg text-xs font-bold disabled:opacity-50 flex items-center justify-center gap-2 shadow-lg shadow-indigo-200">
                                        <Icon name="download" size={16} /> Xuất Order (.txt)
                                    </button>
                                    <button onClick={handleMoveToFinal} disabled={isMovingFiles || !selectedCount} className="w-full py-3 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white rounded-lg text-xs font-bold disabled:opacity-50 flex items-center justify-center gap-2 shadow-lg shadow-green-200">
                                        {isMovingFiles ? <><Icon name="loader" size={16} /> Đang lưu...</> : <><Icon name="folder" size={16} /> Lưu vào Folder</>}
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div className="flex-1 flex flex-col">
                            {/* OPTIMIZED HEADER: White background for light theme */}
                            <header className="h-16 border-b border-gray-200 flex items-center justify-between px-4 md:px-6 bg-white shadow-sm z-10">
                                <div className="flex items-center gap-2 md:gap-3">
                                    {/* Nút Hamburger cho Admin Panel trên mobile */}
                                    {viewMode === 'PHOTOGRAPHER' && (
                                        <button onClick={() => setShowAdminPanel(true)} className="md:hidden -ml-2 p-2 text-gray-500 hover:text-gray-800">
                                            <Icon name="menu" size={24} />
                                        </button>
                                    )}
                                    {/* --- [MỚI] MENU DOWNLOAD --- */}
                                {/* --- MENU DOWNLOAD MỚI --- */}
                                    <div className="relative z-50">
                                        <button
                                            onClick={() => setShowDownloadMenu(!showDownloadMenu)}
                                            className={`w-10 h-10 rounded-xl flex-shrink-0 flex items-center justify-center shadow-lg transition-all active:scale-95 ${showDownloadMenu ? 'bg-pink-600 text-white ring-2 ring-pink-300' : 'bg-gradient-to-br from-pink-500 to-purple-600 text-white shadow-pink-200'}`}
                                        >
                                            <Icon name="camera" size={20} stroke="white" />
                                            {/* Huy hiệu số lượng ảnh đã chọn */}
                                            {viewStats.selected > 0 && (
                                                <div className="absolute -top-1 -right-1 bg-white text-pink-600 text-[10px] font-bold w-4 h-4 rounded-full flex items-center justify-center shadow-sm border border-pink-100">
                                                    {viewStats.selected > 9 ? '9+' : viewStats.selected}
                                                </div>
                                            )}
                                        </button>

                                        {showDownloadMenu && (
                                            <>
                                                <div className="fixed inset-0 z-40" onClick={() => setShowDownloadMenu(false)}></div>
                                                <div className="absolute top-12 left-0 w-72 bg-white rounded-xl shadow-2xl border border-gray-100 z-50 overflow-hidden animate-in fade-in zoom-in-95 duration-200 origin-top-left">
                                                    <div className="bg-gray-50 px-4 py-3 border-b border-gray-100">
                                                        <p className="text-[10px] font-bold text-gray-400 uppercase tracking-wider">Tải về máy (Original)</p>
                                                        <p className="text-xs font-bold text-pink-600 truncate">
                                                            Phạm vi: {currentFolderId ? (driveFolders.find(f => f.id === currentFolderId)?.name || "Thư mục hiện tại") : "Toàn bộ Album"}
                                                        </p>
                                                    </div>
                                                    <div className="p-2 space-y-1">
                                                        {/* NÚT 1: TẢI ẢNH ĐÃ CHỌN */}
                                                        <button 
                                                            onClick={() => handleSmartDownload('SELECTED')} 
                                                            disabled={viewStats.selected === 0} 
                                                            className="w-full text-left px-3 py-3 hover:bg-pink-50 rounded-lg flex items-center gap-3 transition-colors disabled:opacity-40 disabled:cursor-not-allowed group"
                                                        >
                                                            <div className="w-10 h-10 rounded-full bg-pink-100 text-pink-600 group-disabled:bg-gray-100 group-disabled:text-gray-400 flex items-center justify-center flex-shrink-0">
                                                                <Icon name="heart" size={18} fill="currentColor" />
                                                            </div>
                                                            <div>
                                                                <p className="text-sm font-bold text-gray-800 group-disabled:text-gray-500">Tải ảnh Đã chọn</p>
                                                                <p className="text-[10px] text-gray-500">
                                                                    {viewStats.selected} tấm {currentFolderId ? "(trong folder này)" : "(tổng cộng)"}
                                                                </p>
                                                            </div>
                                                        </button>

                                                        {/* NÚT 2: TẢI TẤT CẢ */}
                                                        <button 
                                                            onClick={() => handleSmartDownload('ALL')} 
                                                            className="w-full text-left px-3 py-3 hover:bg-blue-50 rounded-lg flex items-center gap-3 transition-colors group"
                                                        >
                                                            <div className="w-10 h-10 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center flex-shrink-0">
                                                                <Icon name="folder" size={18} />
                                                            </div>
                                                            <div>
                                                                <p className="text-sm font-bold text-gray-800">Tải tất cả ảnh</p>
                                                                <p className="text-[10px] text-gray-500">
                                                                    {currentFolderId ? "Chỉ tải thư mục đang xem" : "Tải toàn bộ album (Chia folder)"}
                                                                </p>
                                                            </div>
                                                        </button>
                                                    </div>
                                                    
                                                    <div className="bg-yellow-50 px-4 py-2 text-[10px] text-yellow-700 border-t border-yellow-100 flex gap-2">
                                                    <Icon name="alert" size={12} />
                                                    <span>PC: Lưu vào folder &bull; Mobile: Tải file Zip</span>
                                                    </div>
                                                </div>
                                            </>
                                        )}
                                    </div>
                                    <h1 className="font-bold text-lg truncate max-w-[150px] md:max-w-none text-gray-800">{albumName}</h1>
                                    
                                    {/* Folder selector cho KHÁCH */}
                                    <div className="hidden md:flex items-center gap-4">
                                        {viewMode === 'CLIENT' && driveFolders.length > 0 && (
                                            <select value={currentFolderId} onChange={(e) => {
                                                setCurrentFolderId(e.target.value);
                                            }} className="bg-gray-50 border border-gray-200 text-gray-700 rounded-lg px-3 py-1.5 text-sm focus:border-pink-500 outline-none max-w-[120px] md:max-w-xs cursor-pointer">
                                                <option value="">Tất cả</option>
                                                {driveFolders.map((folder, idx) => (
                                                    <option key={idx} value={folder.id}>{folder.name}</option>
                                                ))}
                                            </select>
                                        )}
                                        {/* Bộ đếm số ảnh đã chọn */}
                                        {viewMode === 'CLIENT' && viewStats.total > 0 && (
                                            <div className="flex items-center gap-2 bg-gray-100 border border-gray-200 px-3 py-1.5 rounded-lg">
                                                <span className="font-bold text-pink-500">{viewStats.selected}</span>
                                                <Icon name="heart" size={14} className="text-pink-500" fill="currentColor" />
                                                <span className="text-gray-400">/</span>
                                                <span className="text-gray-500">{viewStats.total}</span>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {lastSaveTime && (
                                        <span className="hidden md:flex text-[10px] text-green-600 items-center gap-1 bg-green-50 px-2 py-1 rounded-full" title="Tự động đồng bộ lên Firebase">
                                            <Icon name="checkCircle" size={10} /> Sync: {lastSaveTime.toLocaleTimeString('vi-VN')}
                                        </span>
                                    )}
                                </div>
                                <div className="flex items-center gap-2 -mr-2 md:mr-0">
                                    
                                    <button onClick={() => {
                                        if (isAuthenticated && viewMode === 'PHOTOGRAPHER') {
                                            setIsAuthenticated(false);
                                            setViewMode('CLIENT');
                                            // Xóa token khi Admin chủ động thoát
                                            localStorage.removeItem(`lensflow_admin_token_${albumKey}`);
                                            showToast("Đã thoát chế độ Admin");
                                        } else if (isAuthenticated) {
                                            setViewMode('PHOTOGRAPHER');
                                        } else {
                                            setShowLoginModal(true);
                                        }
                                    }} className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-colors ${viewMode === 'PHOTOGRAPHER' ? 'bg-red-50 text-red-500 border border-red-100 hover:bg-red-100' : 'bg-gray-100 text-gray-600 border border-gray-200 hover:bg-gray-200'}`}>
                                        {viewMode === 'PHOTOGRAPHER' ? <><Icon name="logOut" size={16} /> Exit</> : <><Icon name="lock" size={16} /> Admin</>}
                                    </button>
                                </div>
                            </header>

                            {/* Thanh bộ lọc cho mobile */}
                            {viewMode === 'CLIENT' && (
                                <div className="md:hidden flex items-center gap-2 p-2 border-b border-gray-200 bg-white">
                                    {driveFolders.length > 0 && (
                                        <select value={currentFolderId} onChange={(e) => setCurrentFolderId(e.target.value)} className="flex-1 bg-gray-50 border border-gray-200 text-gray-800 rounded-lg px-3 py-2 text-sm focus:border-pink-500 outline-none">
                                            <option value="">Tất cả thư mục</option>
                                            {driveFolders.map((folder, idx) => (
                                                <option key={idx} value={folder.id}>{folder.name}</option>
                                            ))}
                                        </select>
                                    )}
                                    {viewStats.total > 0 && (
                                        <div className="flex items-center justify-center gap-2 bg-gray-50 border border-gray-200 px-3 py-2 rounded-lg">
                                            <span className="font-bold text-pink-500">{viewStats.selected}</span>
                                            <Icon name="heart" size={14} className="text-pink-500" fill="currentColor" />
                                            <span className="text-gray-400">/</span>
                                            <span className="text-gray-600">{viewStats.total}</span>
                                        </div>
                                    )}
                                </div>
                            )}

                            <main className="flex-1 overflow-hidden relative md:p-4 bg-gray-50">
                                {!photos.length ? (
                                    <div className="h-full flex flex-col items-center justify-center text-gray-400 opacity-50">
                                        <Icon name="grid" size={64} strokeWidth={1} className="mb-4" />
                                        <p className="text-lg font-light">Chưa có ảnh nào</p>
                                    </div>
                                ) : (
									<VirtualPhotoGrid
                                        photos={filteredPhotos}
                                        viewMode={viewMode}
                                        onToggleSelect={toggleSelect}
                                        onUpdateComment={updateComment}
                                        onOpenView={handlePhotoChange}
                                        allowComments={allowComments}
                                        onDownload={handleSingleDownload} // <--- THÊM DÒNG NÀY
                                    />
                                )}
                            </main>

                            <Lightbox 
                                photo={selectedPhoto} 
                                onClose={() => setSelectedPhoto(null)} 
                                allPhotos={filteredPhotos} 
                                onToggleSelect={toggleSelect} 
                                currentIndex={selectedPhotoIndex}
                                onNavigate={handlePhotoChange}
								onDownload={handleSingleDownload}
                            />
                        </div>
                    </>
                    )}
                </div>
            );
        };

        // === ROUTER COMPONENT (Top-level) ===
        // Quyết định hiển thị HomePage hay App dựa trên URL
        const AlbumRouter = () => {
            const urlParams = new URLSearchParams(window.location.search);
            const albumKey = urlParams.get('album');
            const initialAlbumName = urlParams.get('name');

            if (albumKey) {
                // Nếu có album key trong URL, hiển thị App component
                return <App albumKey={albumKey} initialAlbumName={initialAlbumName} />;
            } else {
                // Nếu không, hiển thị trang chủ để tạo/truy cập
                return <AlbumEntryPage />;
            }
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<AlbumRouter />);
    </script>
</body>
</html>
